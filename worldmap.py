import os
import time
import random
from colors import *
from tests.sandbox import *
from classes import *

#--------------------------------------------------------------------------------------------------------------
#
#   Map has been added into the fiefdomgame generation automatically, it is fully functional!
#
#--------------------------------------------------------------------------------------------------------------


#Global variables
MAP_WIDTH = 40
MAP_HEIGHT = 40
DEFAULT_WEIGHT = 10         #A common weight total
WEIGHT_INTENSITY = 5        #Determines how focused the map will be
RANDOM_INTENSITY = 20       #Determines how chaotic the map will be
MAP_SPACER = '              '

#Old River Variables        #I'll get rid of these later
RIVER_MAP_SCANS = 1         #Determines how many times the map is ran through when placing rivers
RIVER_FREQUENCY = 3         #Determines how often rivers will appear
RIVER_FORK_FREQUENCY = 1    #Determines how often rivers will fork
RIVER_LENGTH_INTENSITY = 6  #Determines how long rivers can get
RIVER_AVERAGE_WEIGHT = 0.0
RIVER_RATIO = 60

#New River Variables
SCAN_LEVEL = 3              #Don't change this. Determines how deeply the river generator should search for mountains.
RIVER_COUNT = 0             #Keeps track of how many rivers there have been recorded so far. (For efficiency)
RIVER_CAP = 2               #Maximum number of river sources that can be drawn. (Keep it relatively small)
RIVER_COORDS_0 = []         #Holds 3-tuples of river-coordinates. This holds the tuples for scan level 0
RIVER_COORDS_1 = []         #Holds 3-tuples of river-coordinates. This holds the tuples for scan level 1
RIVER_COORDS_2 = []         #Holds 3-tuples of river-coordinates. This holds the tuples for scan level 2
SOURCES = []                #Holds 3-tuples of river-coordinates that have been randomly picked from the above lists.
FLOOD_WARNING = 60          #This is the maximum number of river tiles that can be drawn for a single river.
FLOOD_COUNTER = 0           #Keeps track of current number of river tiles generated by a single river

#Other Variables
INSTANTLY_GENERATE = False
AUTOMATED = False
FIRST_PRINT = True
LOADING_INCREMENT = 0

#Map Icons
WATER = '~'
RIVER = ['/','|','\\']
MOUNTAIN = 'M'
PLAINS = '#'
FOREST = '^'
FIEF = 'X'
STRONGHOLD = 'H'
EMPTY = ' '
UNEXPLORED = '0'
LOCATION = '@'
RANDOM = '*'
BATTALION = 'B'

#Map Icon Color
IC_WATER = BLUE
IC_RIVER = BLUE
IC_MOUNTAIN = DARK_GRAY
IC_PLAINS = YELLOW
IC_FOREST = GREEN
IC_FIEF = RED
IC_STRONGHOLD = INTENSE_PURPLE
IC_UNEXPLORED = WARNING
IC_LOCATION = INTENSE_PURPLE+CYAN_BACKGROUND+BOLD

#--------------------------------------------------------------------------------------------------------------
#   [GenerateWorldMap]
#   Parameters: seed
#
#   This is the primary function for generating a world map
#   Utilizes a passed 'seed' value that alters how the map is generated
#   The algorithm for generating the map should do the following:
#      1. Begin at a coordinate within a 2D-list
#      2. Write a character on the map
#      3. Move to new location based on current location
#      4. Determine a character to write based on adjacent locations
#      5. Loop through steps 2-4 until map is filled (unique cases aside)
#
#   To make the starting location not matter, the algorithm should scan
#   all adjacent areas to the current coordinate before deciding on a char
#   to write. If no char can be found, the algo should IDEALLY pick a random location
#   and try again. If it comes down to it, a manual scan from coordinate [0,0] onward
#   should be performed so no spaces are left unmarked. Additionally, this adjacency 
#   check should also check diagonal coordinates so that corners are not bottle-necked
#   and ignored. That should increase speed and efficiency.
#   
#   Fief locations will be determined later, but I'd like to have something that detects
#   the name of the fief and picks a location if it, say, has "Forest" in the name. More
#   on that later.
#
#   Algorithm is improvable. Has time-complexity over O(n^2)!
#--------------------------------------------------------------------------------------------------------------
def GenerateWorldMap(seed):
    os.system('clear')

    #Pull globals into this function and reset them:
    global AUTOMATED
    global INSTANTLY_GENERATE
    global FIRST_PRINT
    INSTANTLY_GENERATE = False
    AUTOMATED = False
    FIRST_PRINT = True

    #Define world map and set variables based on seed value:
    worldMap = [['0' for x in range(MAP_WIDTH)] for y in range(MAP_HEIGHT)]
    sPosX = int(seed[0])    #ToDo: Make this coordinate matter
    sPosY = int(seed[1])    #ToDo: Make this coordinate matter
    freqMountain = int(seed[2])
    freqPlains = int(seed[3])
    freqForest = int(seed[4])
    
    loop = True
    firstLoop = True

    #Print title, blank map, etc.
    print('    World Map Devtool')
    print('    WorldMap before inserting anything: \n')
    print(worldMap)
    print('\n')
    print('    Inserting stuff into worldMap: \n')

    while (loop):                                   #This should keep going until the map is filled (currently loops once)
        if firstLoop:                               #Check if this is the first loop (for coordinate stuff later)
            for y in range(MAP_HEIGHT):             #Iterate through each row of the map
                for x in range(MAP_WIDTH):          #Iterate through each symbol in the row
                    #Set the symbol at this location based on surroundings:
                    worldMap[y][x] = DefineSurroundings(worldMap, x, y, freqMountain, freqPlains, freqForest)

            firstLoop = False                       #First loop is done

        loop = False                                #Map should be complete, stop looping.

    print('\n    Finished!')

    return worldMap

#--------------------------------------------------------------------------------------------------------------
#   [DefineSurroundings]
#   Parameters: wMap, posX, posY, freqM, freqP, freqF
#
#   Iterates through the map given the map itself and a set of 
#   values to determine what to write in the next position.
#   ToDo I don't think symb is actually necessary, as it is just the last
#   thing drawn... which should be in the surrounding area.
#   This function could likely benefit from reaching two spaces out instead of just 1, but
#   that would make it far more complex. 
#
#   Issues: While using a 40x40 map, the print is too large and it is not very comfortable to generate the map 
#   this way. Need to cut it down some.
#--------------------------------------------------------------------------------------------------------------
def DefineSurroundings(wMap, posX, posY, freqM, freqP, freqF):
    global AUTOMATED
    global INSTANTLY_GENERATE
    global FIRST_PRINT
    
    #Create points that are surrounding our current position
    #Prints each position at the top of the page:
    if not INSTANTLY_GENERATE:
        os.system("clear")

        surroundings = ScanSurroundings(wMap, posX, posY)
        dN = surroundings[0]
        dNE = surroundings[1]
        dE = surroundings[2]
        dSE = surroundings[3]
        dS = surroundings[4]
        dSW = surroundings[5]
        dW = surroundings[6]
        dNW = surroundings[7]

        #Print surrounding symbols in a relevant box formation
        print('    Surroundings: ' + '    [ posX: ' + str(posX) + ' posY: ' + str(posY) + ' ]') 
        print('    - - - - -')
        print('    - ' + dNW + ' ' + dN + ' ' + dNE + ' -')
        print('    - ' + dW + '   ' + dE + ' -')
        print('    - ' + dSW + ' ' + dS + ' ' + dSE + ' -')
        print('    - - - - -')

        #Define a list of weight totals for each:
        weights = [0, 0, 0, 0, 0, 0, 0, 0]
        #Define a value to iterate through weights with:
        index = 0

        #Calculate the weight totals:
        for i in surroundings:
            if i == UNEXPLORED:
                weights[index] = 0
            elif i == EMPTY:
                weights[index] = 0
            elif i == WATER:
                weights[index] = 10
            elif i == RIVER:
                weights[index] = 10
            elif i == FOREST:
                weights[index] = freqF * WEIGHT_INTENSITY
            elif i == PLAINS:
                weights[index] = freqP * WEIGHT_INTENSITY
            elif i == MOUNTAIN:
                weights[index] =  freqM * WEIGHT_INTENSITY
            elif i == FIEF:
                weights[index] = 0
            elif i == STRONGHOLD:
                weights[index] = 0
            index = index + 1

        #Print weights:
        print('\n    Weights: ') 
        print(*weights)

        #Define a combined list of symbols and weights:
        symbolTable = [(dN,weights[0]),(dNE,weights[1]),(dE,weights[2]),(dSE,weights[3]),(dS,weights[4]),(dSW,weights[5]),(dW,weights[6]),(dNW,weights[7]), (RANDOM,RANDOM_INTENSITY)]

        #Print new combined list:
        print('\n    Symbol Table: ') 
        print(*symbolTable)

        #Define an expanded list of the combined list:
        pointTable = []
        for item, weight in symbolTable:
            pointTable.extend([item]*weight)
        
        #Choose a random item in the list:
        newPoint = random.choice(pointTable)

        #Print the randomly selected symbol:
        print('\n    New Point: ' + str(newPoint))
        print('')
    #If the option to instantly generate the map is selected, no print statements are made:
    else:
        if FIRST_PRINT:
            os.system("clear")
            print('    Generating Map...')
            FIRST_PRINT = False

        surroundings = ScanSurroundings(wMap, posX, posY)
        dN = surroundings[0]
        dNE = surroundings[1]
        dE = surroundings[2]
        dSE = surroundings[3]
        dS = surroundings[4]
        dSW = surroundings[5]
        dW = surroundings[6]
        dNW = surroundings[7]

        #Define a list of weight totals for each:
        weights = [0, 0, 0, 0, 0, 0, 0, 0]
        #Define a value to iterate through weights with:
        index = 0
        #Calculate the weight totals:
        for i in surroundings:
            if i == UNEXPLORED:
                weights[index] = 0
            elif i == EMPTY:
                weights[index] = 0
            elif i == WATER:
                weights[index] = 10
            elif i == RIVER:
                weights[index] = 10
            elif i == FOREST:
                weights[index] = freqF * WEIGHT_INTENSITY
            elif i == PLAINS:
                weights[index] = freqP * WEIGHT_INTENSITY
            elif i == MOUNTAIN:
                weights[index] =  freqM * WEIGHT_INTENSITY
            elif i == FIEF:
                weights[index] = 0
            elif i == STRONGHOLD:
                weights[index] = 0
            index = index + 1
        #Define a combined list of symbols and weights:
        symbolTable = [(dN,weights[0]),(dNE,weights[1]),(dE,weights[2]),(dSE,weights[3]),(dS,weights[4]),(dSW,weights[5]),(dW,weights[6]),(dNW,weights[7]), (RANDOM,RANDOM_INTENSITY)]
        #Define an expanded list of the combined list:
        pointTable = []
        for item, weight in symbolTable:
            pointTable.extend([item]*weight)
        #Choose a random item in the list:
        newPoint = random.choice(pointTable)

    #If the RANDOM symbol was picked, get a random symbol:
    if newPoint == RANDOM:
        newPoint = GetRandomPoint()

    #If the user doesn't wish for the map to be instantly generated, go through the map generation slowly:
    if not INSTANTLY_GENERATE:
        SequentiallyPrintMap(wMap, posX, posY)
    
    #While the map making process isn't automated:
    if not AUTOMATED:
        #Offer the user the option to make each symbol at a time, or automate the process.
        userInput=input('\n    Continue with manual input? press (enter) or type (auto): ')

        if userInput == 'auto':
            AUTOMATED = True
            #Additionally, if the user decides to automate the process, ask if they want it 
            #to be generated instantly:
            if not INSTANTLY_GENERATE:
                userInput=input('    Would you like to instantly generate this map? (y/n): ')
                if userInput == 'y':
                    INSTANTLY_GENERATE = True

    #Return the symbol
    return newPoint

#--------------------------------------------------------------------------------------------------------------
#   [GetRandomPoint]
#   Returns: A random biome symbol
#--------------------------------------------------------------------------------------------------------------
def GetRandomPoint():
    symbolTable = [(WATER, DEFAULT_WEIGHT),(FOREST, DEFAULT_WEIGHT), (PLAINS, DEFAULT_WEIGHT), (MOUNTAIN, DEFAULT_WEIGHT)]
    pointTable = []
    for item, weight in symbolTable:
        pointTable.extend([item]*weight)
    return random.choice(pointTable)

#--------------------------------------------------------------------------------------------------------------
#   [GetRandomLandPoint]
#   Returns: a random solid land biome symbol
#--------------------------------------------------------------------------------------------------------------
def GetRandomLandPoint():
    symbolTable = [(FOREST, DEFAULT_WEIGHT), (PLAINS, DEFAULT_WEIGHT), (MOUNTAIN, DEFAULT_WEIGHT)]
    pointTable = []
    for item, weight in symbolTable:
        pointTable.extend([item]*weight)
    return random.choice(pointTable)

#--------------------------------------------------------------------------------------------------------------
#   [SequentiallyPrintMap]
#   Parameters: wMap, posX, posY
#
#   A visual char-by-char generation of the map
#--------------------------------------------------------------------------------------------------------------
def SequentiallyPrintMap(wMap, posX, posY):
    for i in range(MAP_HEIGHT):
        for j in range(MAP_WIDTH):
            if i == posY and j == posX:
                print(CYAN + wMap[i][j] + RESET, end=" ")
            else:
                print(wMap[i][j], end=" ")
        print('')
    time.sleep(0.1)

#--------------------------------------------------------------------------------------------------------------
#   [PrintColorMap]
#   Parameters: wMap
#
#   Iterates through a WorldMap and prints a color version.
#--------------------------------------------------------------------------------------------------------------
def PrintColorMap(wMap):
    for i in range(MAP_HEIGHT):
        for j in range(MAP_WIDTH):
            symbol = wMap[i][j]
            if j == 0:
                if symbol == UNEXPLORED:
                    print('    ' + IC_UNEXPLORED + symbol + RESET, end=" ")
                elif symbol == EMPTY:
                    print('    ' + symbol, end=" ")
                elif symbol == WATER:
                    print('    ' + IC_WATER + symbol + RESET, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print('    ' + IC_RIVER + symbol + RESET, end=" ")
                elif symbol == FOREST:
                    print('    ' + IC_FOREST + symbol + RESET, end=" ")
                elif symbol == PLAINS:
                    print('    ' + IC_PLAINS + symbol + RESET, end=" ")
                elif symbol == MOUNTAIN:
                    print('    ' + IC_MOUNTAIN + symbol + RESET, end=" ")
                elif symbol == FIEF:
                    print('    ' + IC_FIEF + symbol + RESET, end=" ")
                elif symbol == STRONGHOLD:
                    print('    ' + IC_STRONGHOLD + symbol + RESET, end=" ")
                elif symbol == LOCATION:
                    print('    ' + IC_LOCATION + symbol + RESET, end=" ")
            else:
                if symbol == UNEXPLORED:
                    print(IC_UNEXPLORED + symbol + RESET, end=" ")
                elif symbol == EMPTY:
                    print(symbol, end=" ")
                elif symbol == WATER:
                    print(IC_WATER + symbol + RESET, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(IC_RIVER + symbol + RESET, end=" ")
                elif symbol == FOREST:
                    print(IC_FOREST + symbol + RESET, end=" ")
                elif symbol == PLAINS:
                    print(IC_PLAINS + symbol + RESET, end=" ")
                elif symbol == MOUNTAIN:
                    print(IC_MOUNTAIN + symbol + RESET, end=" ")
                elif symbol == FIEF:
                    print(IC_FIEF + symbol + RESET, end=" ")
                elif symbol == STRONGHOLD:
                    print(IC_STRONGHOLD + symbol + RESET, end=" ")
                elif symbol == LOCATION:
                    print(IC_LOCATION + symbol + RESET, end=" ")
        print('')

#--------------------------------------------------------------------------------------------------------------
#   [PrintColorMapWithFiefs]
#   Parameters: wMap
#
#   Iterates through a WorldMap and prints a color version. Also prints fiefs along side
#--------------------------------------------------------------------------------------------------------------
def PrintColorMapWithFiefs(wMap, userName):
    for i in range(MAP_HEIGHT):
        fiefsInRow = GetFiefRow(i, userName)
        strongholdsInRow = GetStrongholdRow(i, userName)
        for j in range(MAP_WIDTH):
            symbol = wMap[i][j]
            if j == 0:
                if symbol == UNEXPLORED:
                    print(MAP_SPACER + IC_UNEXPLORED + symbol + RESET, end=" ")
                elif symbol == EMPTY:
                    print(MAP_SPACER + symbol, end=" ")
                elif symbol == WATER:
                    print(MAP_SPACER + IC_WATER + symbol + RESET, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(MAP_SPACER + IC_RIVER + symbol + RESET, end=" ")
                elif symbol == FOREST:
                    print(MAP_SPACER + IC_FOREST + symbol + RESET, end=" ")
                elif symbol == PLAINS:
                    print(MAP_SPACER + IC_PLAINS + symbol + RESET, end=" ")
                elif symbol == MOUNTAIN:
                    print(MAP_SPACER + IC_MOUNTAIN + symbol + RESET, end=" ")
                elif symbol == FIEF:
                    print(MAP_SPACER + GetFiefByOwner(i, j, userName) + RESET, end=" ")
                elif symbol == STRONGHOLD:
                    print(MAP_SPACER + IC_STRONGHOLD + symbol + RESET, end=" ")
                elif symbol == LOCATION:
                    print(MAP_SPACER + IC_LOCATION + symbol + RESET, end=" ")
            elif j == MAP_WIDTH - 1:
                if symbol == UNEXPLORED:
                    print(IC_UNEXPLORED + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == EMPTY:
                    print(symbol, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == WATER:
                    print(IC_WATER + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(IC_RIVER + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == FOREST:
                    print(IC_FOREST + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == PLAINS:
                    print(IC_PLAINS + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == MOUNTAIN:
                    print(IC_MOUNTAIN + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == FIEF:
                    print(GetFiefByOwner(i, j, userName) + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == STRONGHOLD:
                    print(IC_STRONGHOLD + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == LOCATION:
                    print(IC_LOCATION + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
            else:
                if symbol == UNEXPLORED:
                    print(IC_UNEXPLORED + symbol + RESET, end=" ")
                elif symbol == EMPTY:
                    print(symbol, end=" ")
                elif symbol == WATER:
                    print(IC_WATER + symbol + RESET, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(IC_RIVER + symbol + RESET, end=" ")
                elif symbol == FOREST:
                    print(IC_FOREST + symbol + RESET, end=" ")
                elif symbol == PLAINS:
                    print(IC_PLAINS + symbol + RESET, end=" ")
                elif symbol == MOUNTAIN:
                    print(IC_MOUNTAIN + symbol + RESET, end=" ")
                elif symbol == FIEF:
                    print(GetFiefByOwner(i, j, userName) + RESET, end=" ")
                elif symbol == STRONGHOLD:
                    print(IC_STRONGHOLD + symbol + RESET, end=" ")
                elif symbol == LOCATION:
                    print(IC_LOCATION + symbol + RESET, end=" ")
        print('')

#--------------------------------------------------------------------------------------------------------------
#   [GetFiefRow]
#   Parameters: row, userName
#   Returns: list of fiefs
#--------------------------------------------------------------------------------------------------------------
def GetFiefRow(row, userName):
    fiefsInRow = []
    # numInRow = 0
    for filename in os.listdir('fiefs'):
            with open(os.path.join('fiefs', filename), 'r') as f:
                tempName = filename[:-4]
                tempName = Fiefdom()
                tempName.name = filename[:-4]
                tempName.read()
                # print('Cross checking with: ' + str(tempName.name))
                if int(tempName.yCoordinate) == row:
                    # numInRow += 1
                    if userName == tempName.ruler:
                        fiefsInRow.append("| " + CYAN + tempName.name + RESET)
                    else:
                        fiefsInRow.append("| " + IC_FIEF + tempName.name + RESET)
    return fiefsInRow

#--------------------------------------------------------------------------------------------------------------
#   [GetFiefByOwner]
#   Parameters: userName
#   Returns: list of fiefs
#--------------------------------------------------------------------------------------------------------------
def GetFiefByOwner(yPos, xPos, userName):
    fief = IC_FIEF + 'X'
    for filename in os.listdir('fiefs'):
            with open(os.path.join('fiefs', filename), 'r') as f:
                tempName = filename[:-4]
                tempName = Fiefdom()
                tempName.name = filename[:-4]
                tempName.read()
                # print('Cross checking with: ' + str(tempName.name))
                if int(tempName.yCoordinate) == yPos and int(tempName.xCoordinate) == xPos and userName == tempName.ruler:
                    fief = CYAN + 'X'

    return fief

#--------------------------------------------------------------------------------------------------------------
#   [GetStrongholdRow]
#   Parameters: row
#   Returns: list of strongholds
#--------------------------------------------------------------------------------------------------------------
def GetStrongholdRow(row, userName):
    strongholdsInRow = []
    numInRow = 0
    for filename in os.listdir('strongholds'):
            with open(os.path.join('strongholds', filename), 'r') as f:
                tempName = filename[:-4]
                tempName = Stronghold()
                tempName.name = filename[:-4]
                tempName.read()
                # print('Cross checking with: ' + str(tempName.name))
                if int(tempName.yCoordinate) == row and tempName.name != "Default Stronghold" and tempName.name != "default":
                    # numInRow += 1
                    # if numInRow == 1:
                        # strongholdsInRow.append("| " + IC_STRONGHOLD + tempName.name + RESET)
                    # else:
                    strongholdsInRow.append("| " + IC_STRONGHOLD + tempName.name + RESET + " ")
    return strongholdsInRow

#--------------------------------------------------------------------------------------------------------------
#   [PrintLegend]
#   Prints a legend for the map
#--------------------------------------------------------------------------------------------------------------
def PrintLegend():
    print('                      -[ Legend ]----------------------------------------------------------------')
    print('                         -  ' + WARNING + 'Water        ' + RESET + ':   ' + IC_WATER + WATER + RESET + '   -' + '                -  ' + WARNING + 'Mountain     ' + RESET + ':   ' + IC_MOUNTAIN + MOUNTAIN + RESET + '   -')
    print('                         -  ' + WARNING + 'Rivers       ' + RESET + ': ' + IC_RIVER + RIVER[0] + RESET + ' ' + IC_RIVER + RIVER[1] + RESET + ' ' + IC_RIVER + RIVER[2] + RESET + ' -' + '                -  ' + WARNING + 'Fief         ' + RESET + ':  ' + IC_FIEF + FIEF + ' ' + CYAN + FIEF + RESET + '  -')
    print('                         -  ' + WARNING + 'Forest       ' + RESET + ':   ' + IC_FOREST + FOREST + RESET + '   -' + '                -  ' + WARNING + 'Stronghold   ' + RESET + ':   ' + IC_STRONGHOLD + STRONGHOLD + RESET + '   -')
    print('                         -  ' + WARNING + 'Plains       ' + RESET + ':   ' + IC_PLAINS + PLAINS + RESET + '   -' + '                -  ' + WARNING + 'You are Here ' + RESET + ':   ' + IC_LOCATION + LOCATION + RESET + '   -')

#--------------------------------------------------------------------------------------------------------------
#   [DefineFiefBiome]
#   Parameters: fiefClass
#
#   Sets a fief's biome based on the fief's name. If no match is found, the fief is assigned a random biome 
#   instead.
#--------------------------------------------------------------------------------------------------------------
def DefineFiefBiome(fiefClass):
    forestBiomeNames = ['forest', 'wood', 'root', 'grove', 'thicket', 'glade', 'pine', 'timber', 'covert', 'canopy']
    plainsBiomeNames = ['plain', 'field', 'prairie', 'flat', 'expanse', 'grass', 'meadow', 'steppe', 'plateau', 'heath', 'moor', 'hollow']
    mountainBiomeNames = ['mount', 'alp', 'bluff', 'cliff', 'crag', 'mesa', 'peak', 'range', 'ridge', 'pike', 'hill', 'butte', 'height']

    print('    Fief name: ' + str(fiefClass.name))
    #Check if the name sounds like a forest
    for i in range(len(forestBiomeNames)):
        if forestBiomeNames[i] in str(fiefClass.name).lower():
            print('    Name contains ' + str(forestBiomeNames[i]) + ", so it's a forest!")
            fiefClass.biome = FOREST
    #Check if the name sounds like a mountain
    for i in range(len(mountainBiomeNames)):
        if mountainBiomeNames[i] in str(fiefClass.name).lower():
            print('    Name contains ' + str(mountainBiomeNames[i]) + ", so it's a mountain!")
            fiefClass.biome = MOUNTAIN
    #Check if the name sounds like a plains
    for i in range(len(plainsBiomeNames)):
        if plainsBiomeNames[i] in str(fiefClass.name).lower():
            print('    Name contains ' + str(plainsBiomeNames[i]) + ", so it's a plains!")
            fiefClass.biome = PLAINS
    #Select randomly if the name doesn't sound like any of the previous biomes
    if fiefClass.biome == '0':
        print('    Fief name does not contain a specific biome type, setting a random biome.')
        fiefClass.biome = GetRandomLandPoint()

    #Update the fiefClass file
    fiefClass.write()

#--------------------------------------------------------------------------------------------------------------
#   [PlotAllFiefs]
#   Parameters: mapClass
#   Plots all fief files on the world map
#--------------------------------------------------------------------------------------------------------------
def PlotAllFiefs(mapClass):
    for filename in os.listdir('fiefs'):
        with open(os.path.join('fiefs', filename), 'r') as f:
            time.sleep(0.3)
            os.system("clear")
            fiefClass = filename[:-4]
            fiefClass = Fiefdom()
            fiefClass.name = filename[:-4]
            fiefClass.read()
            QuietlyPlaceFiefInWorldMap(fiefClass, mapClass)



#--------------------------------------------------------------------------------------------------------------
#   [PlaceFiefInWorldMap]
#   Parameters: fiefClass, mapClass
#
#   Sets a fief's biome based on the fief's name. If no match is found, the fief is assigned a random biome 
#   instead.
#--------------------------------------------------------------------------------------------------------------
def PlaceFiefInWorldMap(fiefClass, mapClass):
    if (fiefClass.biome == '0') and (fiefClass.name != 'Default Fiefdom'):
        DefineFiefBiome(fiefClass)
        print('    Defined Biome as: ' + str(fiefClass.biome))
        remaining = 0
        cycle = 0
        pickingPoint = 0

        #Check if there are still biome slots open for a particular biome.
        #If none are available, then change the fief's biome and try again.
        #If there aren't any open spots at all, then stop the loop.
        while remaining == 0 and cycle < 4:
            remaining = CheckRemainingBiomes(fiefClass.biome, mapClass)
            if remaining == 0:
                fiefClass.biome = CycleBiome(fiefClass.biome)
                cycle += 1
        if cycle > 3:
            print('    Error, no more room for fiefs left on this map!')
        else:
            while pickingPoint < 10:    #Tries to get a point. Fails if it manages to select an occupied point 10 times.
            #Select one of the available biomes at random
                print('    Picking a random ' + str(fiefClass.biome) + ' biome out of the ones available:')
                point = GetRandomPointByBiome(fiefClass.biome, mapClass)
                print('    Picked point: ' + str(point))

                #If a biome was found:
                if point > 0:
                    coordinates = GetPointCoordinates(fiefClass.biome, point, mapClass.worldMap)

                    if CrossCheckFiefCoordinates(coordinates):
                        print('    Successfully selected coordinates!:')
                        print(*coordinates)
                        fiefClass.setCoordinates(coordinates)
                        #This is a new addition that adds several 5 new "surroundings" variables to fiefs:
                        fiefClass.setSurroundings(ScanSurroundings(mapClass.worldMap, fiefClass.xCoordinate, fiefClass.yCoordinate))
                        print('    Successfully set coordinates!: ')
                        print('    xCoordinate: ' + str(fiefClass.xCoordinate) + ' yCoordinate: ' + str(fiefClass.yCoordinate))
                        print('    Updating used biomes in mapClass, biome is ' + str(fiefClass.biome) + ': ')
                        UpdateUsedBiomes(fiefClass.biome, mapClass)
                        print('    Used Forests: ' + str(mapClass.usedForests))
                        print('    Used Plains: ' + str(mapClass.usedPlains))
                        print('    Used Mountains: ' + str(mapClass.usedMountains))
                        print('    Inserting Fief into map:')
                        InsertFiefAtLocation(fiefClass.yCoordinate, fiefClass.xCoordinate, mapClass)
                        
                        PrintColorMap(mapClass.worldMap)

                        fiefClass.write()
                        pickingPoint = 10

                    else:
                        pickingPoint += 1
    else:
        if fiefClass.name == 'Default Fiefdom':
            print("    That fiefdom doesn't exist!")
        else:
            print('    That fief is already on the map!')


#--------------------------------------------------------------------------------------------------------------
#   [QuietlyPlaceFiefInWorldMap]
#   Parameters: fiefClass, mapClass
#
#   Sets a fief's biome based on the fief's name. If no match is found, the fief is assigned a random biome 
#   instead. This version doesn't print as much diagnostic stuff.
#--------------------------------------------------------------------------------------------------------------
def QuietlyPlaceFiefInWorldMap(fiefClass, mapClass):
    if (fiefClass.biome == '0') and (fiefClass.name != 'Default Fiefdom'):
        DefineFiefBiome(fiefClass)
        remaining = 0
        cycle = 0
        pickingPoint = 0
        spotFound = False

        #Check if there are still biome slots open for a particular biome.
        #If none are available, then change the fief's biome and try again.
        #If there aren't any open spots at all, then stop the loop.
        while remaining == 0 and cycle < 4:
            remaining = CheckRemainingBiomes(fiefClass.biome, mapClass)
            if remaining == 0:
                fiefClass.biome = CycleBiome(fiefClass.biome)
                cycle += 1
        if cycle > 3:
            print('    Error, no more room for fiefs left on this map!')
        else:
            while pickingPoint < 10:    #Tries to get a point. Fails if it manages to select an occupied point 10 times.
                #Select one of the available biomes at random
                point = GetRandomPointByBiome(fiefClass.biome, mapClass)
                #If a biome was found:
                if point > 0:
                    coordinates = GetPointCoordinates(fiefClass.biome, point, mapClass.worldMap)

                    if CrossCheckFiefCoordinates(coordinates):
                        print(*coordinates)
                        fiefClass.setCoordinates(coordinates)
                        #This is a new addition that adds several 5 new "surroundings" variables to fiefs:
                        fiefClass.setSurroundings(ScanSurroundings(mapClass.worldMap, fiefClass.xCoordinate, fiefClass.yCoordinate))
                        UpdateUsedBiomes(fiefClass.biome, mapClass)
                        InsertFiefAtLocation(fiefClass.yCoordinate, fiefClass.xCoordinate, mapClass)
                        
                        PrintColorMap(mapClass.worldMap)

                        fiefClass.write()
                        pickingPoint = 10
                        spotFound = True
                    else:
                        pickingPoint += 1
            if spotFound == False:
                print("    Error, couldn't find an empty spot!")
    else:
        if fiefClass.name == 'Default Fiefdom':
            print("    That fiefdom doesn't exist!")
        else:
            print('    ' + str(fiefClass.name) + ' is already on the map!')

#--------------------------------------------------------------------------------------------------------------
#   [InsertFiefAtLocation]
#   Parameters: yPos, xPos, mapClass
#   Finds the x and y position in the world map and writes an X
#--------------------------------------------------------------------------------------------------------------
def InsertFiefAtLocation(yPos, xPos, mapClass):
    for i in range(len(mapClass.worldMap)):
        for j in range(len(mapClass.worldMap[i])):
            if i == yPos and j == xPos:
                mapClass.worldMap[i][j] = FIEF
    mapClass.write()

#--------------------------------------------------------------------------------------------------------------
#   [GetPointCoordinates]
#   Parameters: biome, point, mapClass
#   Returns: a set of coordinates based on the point parameter.
#--------------------------------------------------------------------------------------------------------------
def GetPointCoordinates(biome, point, wMap):
    coordinates = [0, 0]
    counter = 0
    if biome == FOREST:
        for i in range(len(wMap)):
            for j in range(len(wMap[i])):
                if wMap[i][j] == FOREST:
                    counter += 1
                    if counter == point:
                        coordinates[0] = i
                        coordinates[1] = j
    elif biome == PLAINS:
        for i in range(len(wMap)):
            for j in range(len(wMap[i])):
                if wMap[i][j] == PLAINS:
                    counter += 1
                    if counter == point:
                        coordinates[0] = i
                        coordinates[1] = j
    elif biome == MOUNTAIN:
        for i in range(len(wMap)):
            for j in range(len(wMap[i])):
                if wMap[i][j] == MOUNTAIN:
                    counter += 1
                    if counter == point:
                        coordinates[0] = i
                        coordinates[1] = j

    return coordinates

#--------------------------------------------------------------------------------------------------------------
#   [CrossCheckFiefCoordinates]
#   Parameters: coordinates
#   Returns: True if no other fiefs have the same coordinates
#
#   Issues: This is a bit tedious, having to check each file this way. Another way to make this work could be
#   to have an list stored in the Map object that contains tuples of coordinates that are occupied by fiefs.
#   This way, strongholds could benefit from that as well. For now, I'm not so sure I want to mess with the 
#   currently functional map class though after all the read/write woes. 
#--------------------------------------------------------------------------------------------------------------
def CrossCheckFiefCoordinates(coordinates):
    
    for filename in os.listdir('fiefs'):
            with open(os.path.join('fiefs', filename), 'r') as f:
                tempName = filename[:-4]
                tempName = Fiefdom()
                tempName.name = filename[:-4]
                tempName.read()
                # print('Cross checking with: ' + str(tempName.name))
                if tempName.yCoordinate == coordinates[0] and tempName.xCoordinate == coordinates[1]:
                    print('Error, same coordinates as ' + str(tempName.name) + '!')
                    return False
    return True

#--------------------------------------------------------------------------------------------------------------
#   [CrossCheckStrongholdCoordinates]
#   Parameters: coordinates
#   Returns: True if no strongholds have the same coordinates
#--------------------------------------------------------------------------------------------------------------
def CrossCheckStrongholdCoordinates(coordinates):
    
    for filename in os.listdir('strongholds'):
            with open(os.path.join('strongholds', filename), 'r') as f:
                tempName = filename[:-4]
                tempName = Stronghold()
                tempName.name = filename[:-4]
                tempName.read()
                # print('Cross checking with: ' + str(tempName.name))
                if tempName.yCoordinate == coordinates[0] and tempName.xCoordinate == coordinates[1]:
                    print('    Error, same coordinates as ' + str(tempName.name) + '!')
                    return False
    return True

#--------------------------------------------------------------------------------------------------------------
#   [CheckRemainingBiomes]
#   Parameters: biome, mapClass
#   Returns: number of remaining biomes of the passed type in the passed mapClass
#--------------------------------------------------------------------------------------------------------------
def CheckRemainingBiomes(biome, mapClass):
    if biome == FOREST:
        return int(mapClass.numForests) - int(mapClass.usedForests)
    elif biome == MOUNTAIN:
        return int(mapClass.numMountains) - int(mapClass.usedMountains)
    elif biome == PLAINS:
        return int(mapClass.numPlains) - int(mapClass.usedPlains)
    else:
        return 0

#--------------------------------------------------------------------------------------------------------------
#   [GetRandomPointByBiome]
#   Parameters: biome, mapClass
#   Returns: an random int based on the number of matching biomes in the passed mapClass
#--------------------------------------------------------------------------------------------------------------
def GetRandomPointByBiome(biome, mapClass):
    if biome == FOREST:
        return random.randint(1, int(mapClass.numForests))
    if biome == MOUNTAIN:
        return random.randint(1, int(mapClass.numMountains))
    if biome == PLAINS:
        return random.randint(1, int(mapClass.numPlains))

#--------------------------------------------------------------------------------------------------------------
#   [CycleBiome]
#   Parameters: biome
#   Returns: a different biome based on the biome passed
#--------------------------------------------------------------------------------------------------------------
def CycleBiome(biome):
    if biome == FOREST:
        print('    No forests left, changing biome to a mountain:')
        return MOUNTAIN
    elif biome == MOUNTAIN:
        print('    No mountains left, changing biome to a plains:')
        return PLAINS
    elif biome == PLAINS:
        print('    No plains left, changing biome to a forest:')
        return FOREST

#--------------------------------------------------------------------------------------------------------------
#   [UpdateUsedBiomes]
#   Parameters: biome, mapClass
#   Returns: an random int based on the number of matching biomes in the passed mapClass
#--------------------------------------------------------------------------------------------------------------
def UpdateUsedBiomes(biome, mapClass):
    count = 0
    if biome == FOREST:
        count = int(mapClass.usedForests) + 1
        mapClass.usedForests = str(count)
    elif biome == MOUNTAIN:
        count = int(mapClass.usedMountains) + 1
        mapClass.usedMountains = str(count)
    elif biome == PLAINS:
        count = int(mapClass.usedPlains) + 1
        mapClass.usedPlains = str(count)

    mapClass.write()

#--------------------------------------------------------------------------------------------------------------
#   [GetBiomeCounts]
#   Parameters: wMap
#
#   Gets a list containing the number of biomes found in the passed map object.
#   List layout is:
#       [numWater, numRivers, numForest, numMountain, numPlains]
#--------------------------------------------------------------------------------------------------------------
def GetBiomeCounts(wMap):
    numWater = 0
    numRivers = 0
    numForests = 0
    numMountains = 0
    numPlains = 0

    for i in range(len(wMap)):
        for j in range(len(wMap[i])):
            if wMap[i][j] == WATER:
                numWater += 1
            elif wMap[i][j] == RIVER[0] or wMap[i][j] == RIVER[1] or wMap[i][j] == RIVER[2]:
                numRivers += 1
            elif wMap[i][j] == FOREST:
                numForests += 1
            elif wMap[i][j] == MOUNTAIN:
                numMountains += 1
            elif wMap[i][j] == PLAINS:
                numPlains += 1

    biomeCounts = [numWater, numRivers, numForests, numMountains, numPlains]

    return biomeCounts
    

#--------------------------------------------------------------------------------------------------------------
#   [SetBiomeCounts]
#   Parameters: mapClass
#
#   Sets the number of biomes in the map class
#--------------------------------------------------------------------------------------------------------------
def SetBiomeCounts(mapClass):
    biomeCounts = GetBiomeCounts(mapClass.worldMap)
    mapClass.numWater = biomeCounts[0]
    mapClass.numRivers = biomeCounts[1]
    mapClass.numForests = biomeCounts[2]
    mapClass.numMountains = biomeCounts[3]
    mapClass.numPlains = biomeCounts[4]

#--------------------------------------------------------------------------------------------------------------
#   [DefineStrongholdBiome]
#   Parameters: strongholdClass
#   Sets a stronghold's biome randomly.
#--------------------------------------------------------------------------------------------------------------
def DefineStrongholdBiome(strongholdClass):
    strongholdClass.biome = GetRandomLandPoint()
    strongholdClass.write()


#--------------------------------------------------------------------------------------------------------------
#   [PlotAllStrongholds]
#   Parameters: mapClass
#   Plots all stronghold files on the world map (this won't be used too often, since strongholds will
#   typically be added one at a time as new users are made)
#--------------------------------------------------------------------------------------------------------------
def PlotAllStrongholds(mapClass):
    for filename in os.listdir('strongholds'):
        with open(os.path.join('strongholds', filename), 'r') as f:
            time.sleep(0.3)
            os.system("clear")
            strongholdClass = filename[:-4]
            strongholdClass = Stronghold()
            strongholdClass.name = filename[:-4]
            strongholdClass.read()
            QuietlyPlaceStrongholdInWorldMap(strongholdClass, mapClass)



#--------------------------------------------------------------------------------------------------------------
#   [QuietlyPlaceStrongholdInWorldMap]
#   Parameters: strongholdClass, mapClass
#
#   Sets a fief's biome based on the fief's name. If no match is found, the fief is assigned a random biome 
#   instead. This version doesn't print as much diagnostic stuff.
#--------------------------------------------------------------------------------------------------------------
def QuietlyPlaceStrongholdInWorldMap(strongholdClass, mapClass):
    if (strongholdClass.biome == '0') and (strongholdClass.name != 'Default Stronghold'):
        DefineStrongholdBiome(strongholdClass)
        remaining = 0
        cycle = 0
        pickingPoint = 0
        spotFound = False

        #Check if there are still biome slots open for a particular biome.
        #If none are available, then change the stronghold's biome and try again.
        #If there aren't any open spots at all, then stop the loop.
        while remaining == 0 and cycle < 4:
            remaining = CheckRemainingBiomes(strongholdClass.biome, mapClass)
            if remaining == 0:
                strongholdClass.biome = CycleBiome(strongholdClass.biome)
                cycle += 1
        if cycle > 3:
            print('    Error, no more room left on this map!')
        else:
            while pickingPoint < 10:    #Tries to get a point. Fails if it manages to select an occupied point 10 times.
                #Select one of the available biomes at random
                point = GetRandomPointByBiome(strongholdClass.biome, mapClass)
                #If a biome was found:
                if point > 0:
                    #Grab some coordinates:
                    coordinates = GetPointCoordinates(strongholdClass.biome, point, mapClass.worldMap)  
                    #If coordinates aren't the same as some fief:
                    if CrossCheckFiefCoordinates(coordinates):  
                        #If the coordinates aren't the same as some other stronghold:                                        
                        if CrossCheckStrongholdCoordinates(coordinates):   
                            #Update map and stronghold:  
                            print('    Adding ' + str(strongholdClass.name) + "'s stronghold to the map!")                           
                            print(*coordinates)
                            strongholdClass.setCoordinates(coordinates)
                            UpdateUsedBiomes(strongholdClass.biome, mapClass)
                            InsertStrongholdAtLocation(strongholdClass.yCoordinate, strongholdClass.xCoordinate, mapClass)
                            
                            PrintColorMap(mapClass.worldMap)

                            strongholdClass.write()
                            pickingPoint = 10
                            spotFound = True
                        else:
                            pickingPoint += 1
                    else:
                        pickingPoint += 1
            if spotFound == False:
                print("    Error, couldn't find an empty spot!")
    else:
        if strongholdClass.name == 'Default Stronghold':
            print("    That stronghold doesn't exist!")
        else:
            print('    ' + str(strongholdClass.name) + "'s stronghold is already on the map!")


#--------------------------------------------------------------------------------------------------------------
#   [InsertStrongholdAtLocation]
#   Parameters: yPos, xPos, mapClass
#   Finds the x and y position in the world map and writes an H
#--------------------------------------------------------------------------------------------------------------
def InsertStrongholdAtLocation(yPos, xPos, mapClass):
    for i in range(len(mapClass.worldMap)):
        for j in range(len(mapClass.worldMap[i])):
            if i == yPos and j == xPos:
                mapClass.worldMap[i][j] = STRONGHOLD
    mapClass.write()


#--------------------------------------------------------------------------------------------------------------
#   [ScanSurroundings]
#   Parameters: wMap, posX, posY
#   Returns: an array of map symbols in the form: [dN, dNE, dE, dSE, dS, dSW, dW, dNW]
#   where each symbol represents an icon.
#--------------------------------------------------------------------------------------------------------------
def ScanSurroundings(wMap, posX, posY):
    try:
        dN = wMap[posY - 1][posX]
    except:
        dN = ' '
    try:
        dNE = wMap[posY - 1][posX + 1]
    except:
        dNE = ' '
    try:
        dE = wMap[posY][posX + 1]
    except:
        dE = ' '
    try:
        dSE = wMap[posY + 1][posX + 1]
    except:
        dSE = ' '
    try:
        dS = wMap[posY + 1][posX]
    except:
        dS = ' '
    try:
        dSW = wMap[posY + 1][posX - 1]
    except:
        dSW = ' '
    try:
        dW = wMap[posY][posX - 1]
    except:
        dW = ' '
    try:
        dNW = wMap[posY - 1][posX - 1]
    except:
        dNW = ' '

    return [dN, dNE, dE, dSE, dS, dSW, dW, dNW]

#--------------------------------------------------------------------------------------------------------------
#                                           New River Method
#--------------------------------------------------------------------------------------------------------------
#   [DefineRiverSource]
#   Parameters: mapClass, posX, posY, scanLevel
#
#   Scans the map in search of an ideal river source, drawing one consistent river when one is found.
#--------------------------------------------------------------------------------------------------------------
def DefineRiverSource(mapClass, posX, posY, scanLevel):
    global RIVER_COUNT
    global RIVER_COORDS_0
    global RIVER_COORDS_1
    global RIVER_COORDS_2
    #Define a list using the surrounding symbols:
    surroundings = ScanSurroundings(mapClass.worldMap, posX, posY)
    P = mapClass.worldMap[posY][posX]    #Current Position
    dN = surroundings[0]
    dNE = surroundings[1]
    dE = surroundings[2]
    dSE = surroundings[3]
    dS = surroundings[4]
    dSW = surroundings[5]
    dW = surroundings[6]
    dNW = surroundings[7]

    #River source just needs to have a mountain to the north and something else (besides water) below it.
    #If an ideal source is found, then that should be picked over others. 
    #An ideal source looks like something below:
    #       M M -
    #       M - -
    #       - - -
    #Here, the river source could start at the corner of these mountains like below:
    #       M M -
    #       M \ -
    #       - - -
    #There are two ideal sources, and preferably they're closer to the top of the map. 
    #First, scan map for an ideal source.
    #If none are found, then move on.

    
    if NoAdjacentRivers(surroundings) and P!= MOUNTAIN and P!= WATER and dS != MOUNTAIN and dS != WATER:
        # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
        # scanLevel 0:
        # Checks the map for the following two formations:
        #       M M ?           ? M M
        #       M - -           - - M
        #       ? - -           - - ?
        # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
        # if scanLevel == 0 and RIVER_COUNT < RIVER_CAP:    #I may do away with the river cap and instead have this function pick coordinates and compile them into a list
        if scanLevel == 0:
            if dN == MOUNTAIN: # and dS != MOUNTAIN and dS != WATER:
                #   M M ?
                #   M \ -
                #   ? - -
                if dNW == MOUNTAIN and dW == MOUNTAIN and dSE != MOUNTAIN and dSE != WATER and dE != MOUNTAIN and dE != WATER:
                    # print('Ideal southeast-bound source point found! ' + str(posY) + ' ' + str(posX))
                    # mapClass.worldMap[posY][posX] = RIVER[2]
                    RIVER_COUNT += 1
                    RIVER_COORDS_0.append((RIVER[2], int(posY), int(posX)))

                #   ? M M
                #   - / M
                #   - - ?
                elif dNE == MOUNTAIN and dE == MOUNTAIN and dSW != MOUNTAIN and dSW != WATER and dW != MOUNTAIN and dW != WATER:
                    # print('Ideal southwest-bound source point found! ' + str(posY) + ' ' + str(posX))
                    RIVER_COUNT += 1
                    RIVER_COORDS_0.append((RIVER[0], int(posY), int(posX)))
        # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
        # scanLevel 1:
        # Next, need to define what happens when the river source above was too specific. Once here, this is the phase that should be fairly sure to find a source.
        # Here, we'll be looking for any coupled mountains in the following formations:
        #       M M ?       ? M M       M ? ?       ? ? M
        #       ? \ -       - / ?       M \ -       - / M
        #       ? - -       - - ?       ? - -       - - ?
        # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
        # if scanLevel == 1 and RIVER_COUNT < RIVER_CAP:
        if scanLevel == 1:
            if dN == MOUNTAIN: # and dS != MOUNTAIN and dS != WATER:
                if dNW == MOUNTAIN:
                    #   M M ?       M M ?
                    #   ? \ -       ? | -
                    #   ? - -       ? - -
                    if dSE != MOUNTAIN and dSE != WATER and dE != MOUNTAIN and dE != WATER:
                        # print('Second-best south-east bound source point found! ' + str(posY) + ' ' + str(posX))
                        RIVER_COUNT += 1
                        RIVER_COORDS_1.append((RIVER[2], int(posY), int(posX)))
                        #RIVER_COORDS_1.append(RIVER[1], int(posY), int(posX)) #Leave this uncommented if you want the alternate | river version thronw in the mix! --For now, I'll avoid this

                elif dNE == MOUNTAIN:
                    #   ? M M       ? M M
                    #   - / ?       - | ?
                    #   - - ?       - - ?
                    if dSW != MOUNTAIN and dSW != WATER and dW != MOUNTAIN and dW != WATER:
                        RIVER_COUNT += 1
                        # print('Second-best south-west bound source point found! ' + str(posY) + ' ' + str(posX))
                        RIVER_COORDS_1.append((RIVER[0], int(posY), int(posX)))
                        #RIVER_COORDS_1.append(RIVER[1], int(posY), int(posX)) #Leave this uncommented if you want the alternate | river version thronw in the mix! --For now, I'll avoid this
            #   M ? ?
            #   M \ -
            #   ? - -
            elif dNW == MOUNTAIN and dW == MOUNTAIN and dSE != MOUNTAIN and dSE != WATER and dE != MOUNTAIN and dE != WATER:
                # print('Second-best south-east bound source point found! ' + str(posY) + ' ' + str(posX))
                RIVER_COUNT += 1
                RIVER_COORDS_1.append((RIVER[2], int(posY), int(posX)))

            #   ? ? M
            #   - / M
            #   - - ?
            elif dNE == MOUNTAIN and dE == MOUNTAIN and dSW != MOUNTAIN and dSW != WATER and dW != MOUNTAIN and dW != WATER:
                # print('Second-best south-west bound source point found! ' + str(posY) + ' ' + str(posX))
                RIVER_COUNT += 1
                RIVER_COORDS_1.append((RIVER[0], int(posY), int(posX)))
        # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
        # scanLevel 2:
        # At this point, we'll take whatever we can get. So long as a single mountain is in the north and we have a clear shot elsewhere, we will use that. 
        # This is likely only going to come into play when the map just has very few mountains.
        # 
        #       ? M ?      M ? ?      ? ? M 
        #       ? | ?      ? \ ?      ? / ? 
        #       - - -      ? - -      - - ? 
        # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
        if scanLevel == 2:
            #   ? M ? 
            #   ? | ? 
            #   - - - 
            if dN == MOUNTAIN and dSW != MOUNTAIN and dSW != WATER and dSE != MOUNTAIN and dSE != WATER:
                # print('Third-best south bound source point found! ' + str(posY) + ' ' + str(posX))
                RIVER_COORDS_2.append((RIVER[1], int(posY), int(posX)))

            #   M ? ? 
            #   ? \ ? 
            #   ? - - 
            elif dNW == MOUNTAIN and dSE != MOUNTAIN and dSE != WATER:
                RIVER_COORDS_2.append((RIVER[2], int(posY), int(posX)))

            #   ? ? M 
            #   ? / ? 
            #   - - ? 
            elif dNW == MOUNTAIN and dSW != MOUNTAIN and dSW != WATER:
                RIVER_COORDS_2.append((RIVER[0], int(posY), int(posX)))


        #As for scanLevel == 2, that is where the rivers will actually be drawn. 
        #Alternatively, this function can just try to find the river head, then stop after finding one. 
        #Then a new function could make recursive calls to itself and actually simulate a river-flow.

#--------------------------------------------------------------------------------------------------------------
#   [NoAdjacentRivers]
#   Parameters: surroundings
#   Returns: True/False
#   Looks at surroundings and reports if there is a river nearby or not.
#--------------------------------------------------------------------------------------------------------------
def NoAdjacentRivers(surroundings):
    for i in range(len(surroundings)):
        if surroundings[i] == RIVER[0] or surroundings[i] == RIVER[1] or surroundings[i] == RIVER[2]:
            return False
    return True

#--------------------------------------------------------------------------------------------------------------
#   [GenerateRivers]
#   Parameters: mapClass
#
#--------------------------------------------------------------------------------------------------------------
def GenerateRivers(mapClass):
    # global RIVER_MAP_SCANS
    # global RIVER_AVERAGE_WEIGHT
    # RIVER_AVERAGE_WEIGHT = 0.0
    global RIVER_COUNT
    global RIVER_COORDS_0
    global RIVER_COORDS_1
    global RIVER_COORDS_2
    RIVER_COUNT = 0
    RIVER_COORDS_0 = []
    RIVER_COORDS_1 = []
    RIVER_COORDS_2 = []
    # riverSourceCoordinates = ScanForIdealSource(mapClass.worldMap)
    # print('River coords 0 are currently:')
    # print(*RIVER_COORDS_0)
    # print('River coords 1 are currently:')
    # print(*RIVER_COORDS_1)
    for i in range (SCAN_LEVEL):
        print('    Scan Level:' + str(i))
        if RIVER_COUNT < (RIVER_CAP * 2):       #Allows the function to break out of the loop if plenty of ideal spots were found.
            for y in range(MAP_HEIGHT):
                for x in range(MAP_WIDTH):
                    DefineRiverSource(mapClass, y, x, i)
                    # print(mapClass.worldMap[y][x], end=" ")
                # print('')
            # print('\n')
            # PrintColorMap(mapClass.worldMap)

    print('    Total matches found at scan level 0: ' + str(len(RIVER_COORDS_0)))
    print('    Total matches found at scan level 1: ' + str(len(RIVER_COORDS_1)))
    print('    Total matches found at scan level 2: ' + str(len(RIVER_COORDS_2)))
    # mapClass.numRivers = len(RIVER_COORDS_0) #TEMPORARY
    print('    The best river source picks are:')
    print(*RIVER_COORDS_0)
    print('    Waiting for 1 second then picking sources...')
    time.sleep(1)
    PickRiverSources()  # Loads sources into SOURCES global.
    print('    Sources picked:')
    print(*SOURCES)
    print('    Waiting for 1 second then creating rivers:')
    time.sleep(1)
    CreateRivers(mapClass.worldMap)
    # print('Total Average River Weight Value: ' + str(RIVER_AVERAGE_WEIGHT))
    # calculatedWeight = (RIVER_AVERAGE_WEIGHT/(MAP_HEIGHT*MAP_WIDTH))/RIVER_MAP_SCANS
    # print('Total Calculated Average River Weight is: ' + str(calculatedWeight))
    # print('Value for 1:1 ratio is: ' + str(int(calculatedWeight) * 3))
    mapClass.write()


#--------------------------------------------------------------------------------------------------------------
#   [PickRiverSources]
#   Parameters: none
#   Randomly selects the river sources out of the ones available until the RIVER_CAP is met.
#   Goes from RIVER_COORDS_0 -> RIVER_COORDS_1 -> RIVER_COORDS_2
#   The shuffle/pop method guarantees that the same coord won't be picked twice. 
#--------------------------------------------------------------------------------------------------------------
def PickRiverSources():
    global SOURCES
    global RIVER_COORDS_0
    global RIVER_COORDS_1
    global RIVER_COORDS_2
    SOURCES = []
    random.shuffle(RIVER_COORDS_0)
    for i in range(RIVER_CAP):
        try:
            SOURCES.append(RIVER_COORDS_0.pop())
        except:
            pass
    if len(SOURCES) <  RIVER_CAP:
        random.shuffle(RIVER_COORDS_1)
        for i in range(RIVER_CAP - int(len(SOURCES))):
            try:
                SOURCES.append(RIVER_COORDS_1.pop())
                if DuplicateCoordinates():
                    SOURCES.pop()
            except:
                pass
    #If not enough river sources were found still:
    if len(SOURCES) <  RIVER_CAP:
        random.shuffle(RIVER_COORDS_2)
        for i in range(RIVER_CAP - int(len(SOURCES))):
            try:
                SOURCES.append(RIVER_COORDS_2.pop())
                if DuplicateCoordinates():
                    SOURCES.pop()
            except:
                pass

#--------------------------------------------------------------------------------------------------------------
#   [DuplicateCoordinates]
#   Parameters: none
#
#   Checks if SOURCES global has duplicate coordinates
#--------------------------------------------------------------------------------------------------------------
def DuplicateCoordinates():
    # global SOURCES
    tempList = SOURCES
    tempList = iter(tempList)
    # try:
    first = next(tempList, None)
    # except StopIteration:
    #     return True
    return all(first == x for x in tempList)

#--------------------------------------------------------------------------------------------------------------
#   [CreateRivers]
#   Parameters: wMap
#   Calls SimulateRivers for each tuple in SOURCES
#--------------------------------------------------------------------------------------------------------------
def CreateRivers(wMap):
    #Unpack SOURCES:
    global FLOOD_COUNTER
    for i in range(len(SOURCES)):
        FLOOD_COUNTER = 0
        symbol = SOURCES[i][0]
        y = SOURCES[i][1]
        x = SOURCES[i][2]
        SimulateRivers(wMap, symbol, y, x)

#--------------------------------------------------------------------------------------------------------------
#   [RunSouthEast]
#   Parameters: dS, dSE, wMap, y, x, lean
#   Runs river southeast based on passed values
#--------------------------------------------------------------------------------------------------------------
def RunSouthEast(dS, dSE, wMap, y, x, lean):
    if lean == 'none':
        if dS == PLAINS:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        if dSE == PLAINS:
            return SimulateRivers(wMap, RIVER[2], y + 1, x + 1)
        if dS == FOREST:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        if dSE == FOREST:
            return SimulateRivers(wMap, RIVER[2], y + 1, x + 1)
    if lean == 'south':
        if dS == PLAINS:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        if dS == FOREST:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        if dSE == PLAINS:
            return SimulateRivers(wMap, RIVER[2], y + 1, x + 1)
        if dSE == FOREST:
            return SimulateRivers(wMap, RIVER[2], y + 1, x + 1)
    if lean == 'east':
        if dSE == PLAINS:
            return SimulateRivers(wMap, RIVER[2], y + 1, x + 1)
        if dSE == FOREST:
            return SimulateRivers(wMap, RIVER[2], y + 1, x + 1)
        if dS == PLAINS:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        if dS == FOREST:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        

#--------------------------------------------------------------------------------------------------------------
#   [RunSouthWest]
#   Parameters: dSW, dS, wMap, y, x, lean
#   Runs river southwest based on passed values
#--------------------------------------------------------------------------------------------------------------
def RunSouthWest(dSW, dS, wMap, y, x, lean):
    if lean == 'none':
        if dS == PLAINS:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        if dSW == PLAINS:
            return SimulateRivers(wMap, RIVER[0], y + 1, x - 1)
        if dS == FOREST:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        if dSW == FOREST:
            return SimulateRivers(wMap, RIVER[0], y + 1, x - 1)
    if lean == 'south':
        if dS == PLAINS:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        if dS == FOREST:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        if dSW == PLAINS:
            return SimulateRivers(wMap, RIVER[0], y + 1, x - 1)
        if dSW == FOREST:
            return SimulateRivers(wMap, RIVER[0], y + 1, x - 1)
    if lean == 'west':
        if dSW == PLAINS:
            return SimulateRivers(wMap, RIVER[0], y + 1, x - 1)
        if dSW == FOREST:
            return SimulateRivers(wMap, RIVER[0], y + 1, x - 1)
        if dS == PLAINS:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        if dS == FOREST:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        
#--------------------------------------------------------------------------------------------------------------
#   [RandomRunSouthWest]
#   Parameters: dSW, dS, wMap, y, x
#   Runs river southwest based on passed values
#--------------------------------------------------------------------------------------------------------------
def RandomRunSouthWest(dSW, dS, wMap, y, x):
    ch2 = random.randint(1, 2)
    #If both dS and dSW are plains:
    if dS == PLAINS and dSW == PLAINS:
        if ch2 == 1:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        elif ch2 == 2:
            return SimulateRivers(wMap, RIVER[0], y + 1, x - 1)
    #If both dS and dSW are forests:
    elif dS == FOREST and dSW == FOREST:
        if ch2 == 1:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        elif ch2 == 2:
            return SimulateRivers(wMap, RIVER[0], y + 1, x - 1)

#--------------------------------------------------------------------------------------------------------------
#   [RandomRunSouthEast]
#   Parameters: dSW, dS, wMap, y, x
#   Runs river southeast based on passed values, randomly selecting
#--------------------------------------------------------------------------------------------------------------
def RandomRunSouthEast(dS, dSE, wMap, y, x):
    ch2 = random.randint(1, 2)
    #If both dS and dSE are plains:
    if dS == PLAINS and dSE == PLAINS:
        if ch2 == 1:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        elif ch2 == 2:
            return SimulateRivers(wMap, RIVER[2], y + 1, x + 1)
    #If both dS and dSE are forests:
    elif dS == FOREST and dSE == FOREST:
        if ch2 == 1:
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        elif ch2 == 2:
            return SimulateRivers(wMap, RIVER[2], y + 1, x + 1)

#--------------------------------------------------------------------------------------------------------------
#   [SimulateRivers]
#   Parameters: wMap, symbol, y, x
#   Returns: Recursively returns itself until conditions are met.
#   Draws the rivers based on their current positions.
#  
#       Function prefers to spread to plains over forests.
#       At this point, we know that if the symbol is "\", then dS and dSE are each either a forest or a plains.
#       Additionally if the symbol is RIVER[1], then dSW, dS, and dSE are each a ^ or a # too. And finally if the 
#       symbol is "/", we know that the same is true for dSW and dS.
#       When multiple options are the same, however, that is when things get complex. 
#       The preferred direction should depend on what lies on the dE and dW. 
#       If those are in the same category (( Sources: M, ~ ), ( Spreadable: #, ^ )) then it should
#       select randomly. 
#--------------------------------------------------------------------------------------------------------------
def SimulateRivers(wMap, symbol, y, x):
    global FLOOD_COUNTER
    try:
        wMap[y][x] = symbol
    except:
        return wMap

    if FLOOD_COUNTER >= FLOOD_WARNING:
        return wMap
    else:
        FLOOD_COUNTER += 1

    os.system("clear")
    PrintColorMap(wMap)
    time.sleep(0.1)
    surroundings = ScanSurroundings(wMap, x, y)
    dE = surroundings[2]
    dSE = surroundings[3]
    dS = surroundings[4]
    dSW = surroundings[5]
    dW = surroundings[6]

    # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    # If river is headed southeast:
    # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    if symbol == RIVER[2]:
        #if dW and dE are in the same category:
        if ((dW == MOUNTAIN or dW == WATER) and (dE == MOUNTAIN or dE == WATER)) or ((dW != MOUNTAIN or dW != WATER) and (dE != MOUNTAIN or dE != WATER)):
            #First, run to see if dS and dSE are the same, and choose randomly in that case:
            RandomRunSouthEast(dS, dE, wMap, y, x)
            #If they were not the same, then just check for plains first:
            RunSouthEast(dS, dE, wMap, y, x, 'none')

        #Otherwise, if west is not spreadable
        elif dW == MOUNTAIN or dW == WATER:
            #If both dS and dSE are plains:
            if dS == PLAINS and dSE == PLAINS:
                #Prefer the east:
                return SimulateRivers(wMap, RIVER[2], y + 1, x + 1)
            #If both dS and dSE are forests:
            elif dS == FOREST and dSE == FOREST:
                #Prefer the east:
                return SimulateRivers(wMap, RIVER[2], y + 1, x + 1)
            #if dS and dSE are not the same:
            else:
                RunSouthEast(dS, dE, wMap, y, x, 'east')

        #Otherwise, if east is not spreadable
        elif dE == MOUNTAIN or dE == WATER:
            #If both dS and dSE are plains:
            if dS == PLAINS and dSE == PLAINS:
                #Prefer the south:
                return SimulateRivers(wMap, RIVER[1], y + 1, x)
            #If both dS and dSE are forests:
            elif dS == FOREST and dSE == FOREST:
                #Prefer the south:
                return SimulateRivers(wMap, RIVER[1], y + 1, x)
            #if dS and dSE are not the same:
            else:
                RunSouthEast(dS, dE, wMap, y, x, 'south')

    # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    # If a river is headed southwest:
    # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    elif symbol == RIVER[0]:
        #if dW and dE are in the same category:
        if ((dW == MOUNTAIN or dW == WATER) and (dE == MOUNTAIN or dE == WATER)) or ((dW != MOUNTAIN or dW != WATER) and (dE != MOUNTAIN or dE != WATER)):
            #First, run to see if dS and dSE are the same, and choose randomly in that case:
            RandomRunSouthWest(dSW, dS, wMap, y, x)
            #If they were not the same, then just check for plains first:
            RunSouthWest(dSW, dS, wMap, y, x, 'none')

        #Otherwise, if east is not spreadable
        elif dE == MOUNTAIN or dE == WATER:
            #If both dS and dSE are plains:
            if dS == PLAINS and dSE == PLAINS:
                #Prefer the south:
                return SimulateRivers(wMap, RIVER[0], y + 1, x - 1)
            #If both dS and dSE are forests:
            elif dS == FOREST and dSE == FOREST:
                #Prefer the south:
                return SimulateRivers(wMap, RIVER[0], y + 1, x - 1)
            #if dS and dSE are not the same:
            else:
                RunSouthWest(dSW, dS, wMap, y, x, 'west')

        #Otherwise, if west is not spreadable
        elif dW == MOUNTAIN or dW == WATER:
            #If both dS and dSE are plains:
            if dS == PLAINS and dSE == PLAINS:
                #Prefer the east:
                return SimulateRivers(wMap, RIVER[1], y + 1, x)
            #If both dS and dSE are forests:
            elif dS == FOREST and dSE == FOREST:
                #Prefer the east:
                return SimulateRivers(wMap, RIVER[1], y + 1, x)
            #if dS and dSE are not the same:
            else:
                RunSouthWest(dSW, dS, wMap, y, x, 'south')

    # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    # If a river is headed south:
    # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    elif symbol == RIVER[1]:
        #if neither dW nor dE are spreadable, then run south:
        if (dW == MOUNTAIN or dW == WATER) and (dE == MOUNTAIN or dE == WATER):
            return SimulateRivers(wMap, RIVER[1], y + 1, x)
        #if both dW and dE are spreadable:
        elif (dW != MOUNTAIN or dW != WATER) and (dE != MOUNTAIN or dE != WATER):
            #If everything is the same to the south, then choose randomly between both directions:
            if (dSW == PLAINS and dS == PLAINS and dSE == PLAINS) or (dSW == FOREST and dS == FOREST and dSE == FOREST):
                #Then choose a random direction
                ch2 = random.randint(1, 2)
                if ch2 == 1:
                    RandomRunSouthWest(dSW, dS, wMap, y, x)
                else:
                    RandomRunSouthEast(dS, dSE, wMap, y, x)
            #Otherwise, check plains if one side has two plains first before deciding:
            elif (dSW == PLAINS and dS == PLAINS):
                RandomRunSouthWest(dSW, dS, wMap, y, x)
            elif (dS == PLAINS and dSE == PLAINS):
                RandomRunSouthEast(dS, dSE, wMap, y, x)
            elif (dSW == FOREST and dS == FOREST):
                RandomRunSouthWest(dSW, dS, wMap, y, x)
            elif (dS == FOREST and dSE == FOREST):
                RandomRunSouthEast(dS, dSE, wMap, y, x)
            #Otherwise, check which side has a plains (at this point, exactly one plains must exist):
            elif dS == PLAINS:
                ch2 = random.randint(1, 2)
                if ch2 == 1:
                    RunSouthWest(dSW, dS, wMap, y, x, 'south')
                else:
                    RunSouthEast(dS, dSE, wMap, y, x, 'south')
            elif dSW == PLAINS:
                RunSouthWest(dSW, dS, wMap, y, x, 'west')
            elif dSE == PLAINS:
                RunSouthEast(dS, dSE, wMap, y, x, 'east')

        #Otherwise, if east is not spreadable
        elif dE == MOUNTAIN or dE == WATER:
            #If everything is plains to the south (or so long as dSW and dS are plains), then prefer southwest.
            if (dSW == PLAINS and dS == PLAINS and dSE == PLAINS) or (dSW == PLAINS and dS == PLAINS):
                RandomRunSouthWest(dSW, dS, wMap, y, x)
            #Otherwise, if dS and dE are both plains, prefer south:
            elif dS == PLAINS and dSE == PLAINS:
                return SimulateRivers(wMap, RIVER[1], y + 1, x)
            #Otherwise, if dSW is the only plains, go southwest:
            elif dSW == PLAINS:
                return SimulateRivers(wMap, RIVER[0], y + 1, x - 1)
            #Otherwise, if dS is the only plains, go south:
            elif dS == PLAINS:
                return SimulateRivers(wMap, RIVER[1], y + 1, x)

            #Otherwise, everything south must just be forests, so run randomly to the southwest:
            RandomRunSouthWest(dSW, dS, wMap, y, x)

        #Otherwise, if west is not spreadable
        elif dW == MOUNTAIN or dW == WATER:
            #If everything is plains to the south (or so long as dSE and dS are plains), then prefer southeast.
            if (dSW == PLAINS and dS == PLAINS and dSE == PLAINS) or (dSE == PLAINS and dS == PLAINS):
                RandomRunSouthEast(dS, dSE, wMap, y, x)
            #Otherwise, if dS and dW are both plains, prefer south:
            elif dS == PLAINS and dSW == PLAINS:
                return SimulateRivers(wMap, RIVER[1], y + 1, x)
            #Otherwise, if dSE is the only plains, go southeast:
            elif dSE == PLAINS:
                return SimulateRivers(wMap, RIVER[2], y + 1, x + 1)
            #Otherwise, if dS is the only plains, go south:
            elif dS == PLAINS:
                return SimulateRivers(wMap, RIVER[1], y + 1, x)

            #Otherwise, everything south must just be forests, so run randomly to the southeast:
            RandomRunSouthEast(dS, dSE, wMap, y, x)



#--------------------------------------------------------------------------------------------------------------
#   [WorldMapLocation]
#   Parameters: yPos, xPos, mapClass
#   Replaces current x and y position in the world map with a new icon, prints the map, then reverts the map.
#--------------------------------------------------------------------------------------------------------------
def WorldMapLocation(yPos, xPos, mapClass, userName):
    tempIcon = mapClass.worldMap[yPos][xPos]
    mapClass.worldMap[yPos][xPos] = LOCATION
    PrintColorMapWithFiefs(mapClass.worldMap, userName)
    mapClass.worldMap[yPos][xPos] = tempIcon

#--------------------------------------------------------------------------------------------------------------
#   [ListSurroundings]
#   Parameters: wMap, xPos, yPos
#   Lists out the biomes surrounding the current location.
#--------------------------------------------------------------------------------------------------------------
def ListSurroundings(wMap, xPos, yPos):
    surroundings = ScanSurroundings(wMap, int(xPos), int(yPos))

    directions = ['North', 'North-East', 'East', 'South-East', 'South', 'South-West', 'West', 'North-West']
    for i in range(len(surroundings)):
        if surroundings[i] == WATER:
            print('    There is a ' + IC_WATER + 'lake' + RESET + ' to the ' + str(directions[i]) + '.')
        if surroundings[i] == RIVER[0]:
            print('    There is a South-West bound ' + IC_RIVER + 'river' + RESET + ' to the ' + str(directions[i]) + '.')
        if surroundings[i] == RIVER[1]:
            print('    There is a South bound ' + IC_RIVER + 'river' + RESET + ' to the ' + str(directions[i]) + '.')
        if surroundings[i] == RIVER[2]:
            print('    There is a South-East bound ' + IC_RIVER + 'river' + RESET + ' to the ' + str(directions[i]) + '.')
        if surroundings[i] == PLAINS:
            print('    There are ' + IC_PLAINS + 'plains' + RESET + ' to the ' + str(directions[i]) + '.')
        if surroundings[i] == FOREST:
            print('    There is a ' + IC_FOREST + 'forest' + RESET + ' to the ' + str(directions[i]) + '.')
        if surroundings[i] == MOUNTAIN:
            print('    There are ' + IC_MOUNTAIN + 'mountains' + RESET + ' to the ' + str(directions[i]) + '.')
        if surroundings[i] == FIEF:
            print('    There is a ' + IC_FIEF + 'fiefdom' + RESET + ' to the ' + str(directions[i]) + '.')
        if surroundings[i] == STRONGHOLD:
            print('    There is a ' + IC_STRONGHOLD + 'stronghold' + RESET + ' to the ' + str(directions[i]) + '.')
        if surroundings[i] == ' ':
            print('    There is a vast wasteland to the ' +  str(directions[i]) + '.')

#--------------------------------------------------------------------------------------------------------------
#   [GenerateSeed]
#
#   Generates a random "seed" value for the map to add further variation in map generation.
#   Currently not very intuitive, likely land-heavy. Needs fine-tuning!
#--------------------------------------------------------------------------------------------------------------
def GenerateSeed():
    seed = ''
    x = 0
    y = 0
    biomeMountain = random.randint(2, 7)
    biomePlains = random.randint(1, 9)
    biomeForest = random.randint(1, 9)
    
    seed += str(x)
    seed += str(y)
    seed += str(biomeMountain)
    seed += str(biomePlains)
    seed += str(biomeForest)

    return seed

    

#--------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------
#                               SILENT FUNCTIONS (GET RID OF THESE AT SOME POINT...)
#--------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------

#--------------------------------------------------------------------------------------------------------------
#   [SilentlyGenerateWorld]
#   Parameters: mapClass
#   This function combines the other functions to silently generate the world in the background.
#--------------------------------------------------------------------------------------------------------------
def SilentlyGenerateWorld(mapClass):
    mapClass.name = 'serverMap'
    mapClass.seed = GenerateSeed()
    mapClass.height = MAP_HEIGHT
    mapClass.width = MAP_WIDTH
    # LoadingAnimation('Generating World Map')
    mapClass.worldMap = SilentlyGenerateWorldMap(mapClass.seed)
    SilentlyGenerateRivers(mapClass)
    SetBiomeCounts(mapClass)
    mapClass.write()
    # LoadingAnimation('Placing Fiefs and Strongholds')
    # mapClass.read()
    # mapClass.read()
    SilentlyPlotAllFiefs(mapClass)
    SilentlyPlotAllStrongholds(mapClass)


#--------------------------------------------------------------------------------------------------------------
#   [SilentlyGenerateWorldMap]
#   Parameters: seed
#
#   Does the same thing as GenerateWordlMap but with no prints or user interaction
#--------------------------------------------------------------------------------------------------------------
def SilentlyGenerateWorldMap(seed):
    worldMap = [['0' for x in range(MAP_WIDTH)] for y in range(MAP_HEIGHT)]
    sPosX = int(seed[0])
    sPosY = int(seed[1])
    freqMountain = int(seed[2])
    freqPlains = int(seed[3])
    freqForest = int(seed[4])
    
    loop = True
    firstLoop = True
    while (loop):
        if firstLoop:
            for y in range(MAP_HEIGHT):
                for x in range(MAP_WIDTH):
                    worldMap[y][x] = SilentlyDefineSurroundings(worldMap, x, y, freqMountain, freqPlains, freqForest)

            firstLoop = False
        loop = False
    return worldMap

#--------------------------------------------------------------------------------------------------------------
#   [SilentlyCreateRivers]
#   Parameters: wMap
#   Calls SimulateRivers for each tuple in SOURCES
#--------------------------------------------------------------------------------------------------------------
def SilentlyCreateRivers(wMap):
    #Unpack SOURCES:
    global FLOOD_COUNTER
    for i in range(len(SOURCES)):
        FLOOD_COUNTER = 0
        symbol = SOURCES[i][0]
        y = SOURCES[i][1]
        x = SOURCES[i][2]
        SilentlySimulateRivers(wMap, symbol, y, x)

#--------------------------------------------------------------------------------------------------------------
#   [SilentlyGenerateRivers]
#   Parameters: mapClass
#
#--------------------------------------------------------------------------------------------------------------
def SilentlyGenerateRivers(mapClass):
    global RIVER_COUNT
    global RIVER_COORDS_0
    global RIVER_COORDS_1
    global RIVER_COORDS_2
    RIVER_COUNT = 0
    RIVER_COORDS_0 = []
    RIVER_COORDS_1 = []
    RIVER_COORDS_2 = []
    for i in range (SCAN_LEVEL):
        if RIVER_COUNT < (RIVER_CAP * 2):       #Allows the function to break out of the loop if plenty of ideal spots were found.
            for y in range(MAP_HEIGHT):
                for x in range(MAP_WIDTH):
                    DefineRiverSource(mapClass, y, x, i)
    PickRiverSources()
    SilentlyCreateRivers(mapClass.worldMap)
    mapClass.write()

#--------------------------------------------------------------------------------------------------------------
#   [SilentlyDefineSurroundings]
#   Parameters: wMap, posX, posY, freqM, freqP, freqF
#
#   Does the same thing as PrintSurroundings but with no prints or user interaction
#--------------------------------------------------------------------------------------------------------------
def SilentlyDefineSurroundings(wMap, posX, posY, freqM, freqP, freqF):
    surroundings = ScanSurroundings(wMap, posX, posY)
    dN = surroundings[0]
    dNE = surroundings[1]
    dE = surroundings[2]
    dSE = surroundings[3]
    dS = surroundings[4]
    dSW = surroundings[5]
    dW = surroundings[6]
    dNW = surroundings[7]

    #Define a list of weight totals for each:
    weights = [0, 0, 0, 0, 0, 0, 0, 0]
    index = 0

    #Calculate the weight totals:
    for i in surroundings:
        if i == UNEXPLORED:
            weights[index] = 0
        elif i == EMPTY:
            weights[index] = 0
        elif i == WATER:
            weights[index] = 10
        elif i == RIVER:
            weights[index] = 10
        elif i == FOREST:
            weights[index] = freqF * WEIGHT_INTENSITY
        elif i == PLAINS:
            weights[index] = freqP * WEIGHT_INTENSITY
        elif i == MOUNTAIN:
            weights[index] =  freqM * WEIGHT_INTENSITY
        elif i == FIEF:
            weights[index] = 0
        elif i == STRONGHOLD:
            weights[index] = 0
        index = index + 1

    #Define a combined list of symbols and weights, including the RANDOM option.
    symbolTable = [(dN,weights[0]),(dNE,weights[1]),(dE,weights[2]),(dSE,weights[3]),(dS,weights[4]),(dSW,weights[5]),(dW,weights[6]),(dNW,weights[7]), (RANDOM,RANDOM_INTENSITY)]

    #Define a table to extend values based on weights and pull a random choice from it
    pointTable = []
    for item, weight in symbolTable:
        pointTable.extend([item]*weight)
    newPoint = random.choice(pointTable)

    #IF the random choice is selected, get a random point.
    if newPoint == RANDOM:
        newPoint = GetRandomPoint()

    #Return the symbol
    return newPoint

#--------------------------------------------------------------------------------------------------------------
#   [SilentlyPlaceStrongholdInWorldMap]
#   Parameters: strongholdClass, mapClass
#
#   These are getting redundant, I know. 
#   Sets a fief's biome based on the fief's name. If no match is found, the fief is assigned a random biome 
#   instead. This version doesn't print a single thing unless an error happens.
#--------------------------------------------------------------------------------------------------------------
def SilentlyPlaceStrongholdInWorldMap(strongholdClass, mapClass):
    if (strongholdClass.biome == '0') and (strongholdClass.name != 'Default Stronghold'):
        DefineStrongholdBiome(strongholdClass)
        remaining = 0
        cycle = 0
        pickingPoint = 0
        spotFound = False

        #Check if there are still biome slots open for a particular biome.
        #If none are available, then change the stronghold's biome and try again.
        #If there aren't any open spots at all, then stop the loop.
        while remaining == 0 and cycle < 4:
            remaining = CheckRemainingBiomes(strongholdClass.biome, mapClass)
            if remaining == 0:
                strongholdClass.biome = CycleBiome(strongholdClass.biome)
                cycle += 1
        if cycle > 3:
            print('    Error, no more room left on this map!')
        else:
            while pickingPoint < 10:    #Tries to get a point. Fails if it manages to select an occupied point 10 times.
                #Select one of the available biomes at random
                point = GetRandomPointByBiome(strongholdClass.biome, mapClass)
                #If a biome was found:
                if point > 0:
                    #Grab some coordinates:
                    coordinates = GetPointCoordinates(strongholdClass.biome, point, mapClass.worldMap)  
                    #If coordinates aren't the same as some fief:
                    if CrossCheckFiefCoordinates(coordinates):  
                        #If the coordinates aren't the same as some other stronghold:                                        
                        if CrossCheckStrongholdCoordinates(coordinates):   
                            #Update map and stronghold:  
                            strongholdClass.setCoordinates(coordinates)
                            UpdateUsedBiomes(strongholdClass.biome, mapClass)
                            InsertStrongholdAtLocation(strongholdClass.yCoordinate, strongholdClass.xCoordinate, mapClass)

                            strongholdClass.write()
                            pickingPoint = 10
                            spotFound = True
                        else:
                            pickingPoint += 1
                    else:
                        pickingPoint += 1
            if spotFound == False:
                print("    Error, couldn't find an empty spot!")
    else:
        if strongholdClass.name == 'Default Stronghold':
            # print("    That stronghold doesn't exist!")
            pass
        else:
            print('    ' + str(strongholdClass.name) + "'s stronghold is already on the map!")

#--------------------------------------------------------------------------------------------------------------
#   [SilentlyPlaceFiefInWorldMap]
#   Parameters: fiefClass, mapClass
#
#   Sets a fief's biome based on the fief's name. If no match is found, the fief is assigned a random biome 
#   instead. This version doesn't print anything unless an error occurs.
#--------------------------------------------------------------------------------------------------------------
def SilentlyPlaceFiefInWorldMap(fiefClass, mapClass):
    if (fiefClass.biome == '0') and (fiefClass.name != 'Default Fiefdom'):
        SilentlyDefineFiefBiome(fiefClass)
        remaining = 0
        cycle = 0
        pickingPoint = 0
        spotFound = False

        #Check if there are still biome slots open for a particular biome.
        #If none are available, then change the fief's biome and try again.
        #If there aren't any open spots at all, then stop the loop.
        while remaining == 0 and cycle < 4:
            remaining = CheckRemainingBiomes(fiefClass.biome, mapClass)
            if remaining == 0:
                fiefClass.biome = CycleBiome(fiefClass.biome)
                cycle += 1
        if cycle > 3:
            print('    Error, no more room for fiefs left on this map!')
        else:
            while pickingPoint < 10:    #Tries to get a point. Fails if it manages to select an occupied point 10 times.
                #Select one of the available biomes at random
                point = GetRandomPointByBiome(fiefClass.biome, mapClass)
                #If a biome was found:
                if point > 0:
                    coordinates = GetPointCoordinates(fiefClass.biome, point, mapClass.worldMap)

                    if CrossCheckFiefCoordinates(coordinates):
                        if CrossCheckStrongholdCoordinates(coordinates):
                            fiefClass.setCoordinates(coordinates)
                            #This is a new addition that adds several 5 new "surroundings" variables to fiefs:
                            fiefClass.setSurroundings(ScanSurroundings(mapClass.worldMap, fiefClass.xCoordinate, fiefClass.yCoordinate))
                            UpdateUsedBiomes(fiefClass.biome, mapClass)
                            InsertFiefAtLocation(fiefClass.yCoordinate, fiefClass.xCoordinate, mapClass)
                            fiefClass.write()
                            pickingPoint = 10
                            spotFound = True
                        else:
                            pickingPoint += 1
                    else:
                        pickingPoint += 1
            if spotFound == False:
                print("    Error, couldn't find an empty spot!")
    else:
        if fiefClass.name == 'Default Fiefdom':
            print("    That fiefdom doesn't exist!")
        else:
            print('    ' + str(fiefClass.name) + ' is already on the map!')

#--------------------------------------------------------------------------------------------------------------
#   [SilentlyPlotAllFiefs]
#   Parameters: mapClass
#   Plots all fief files on the world map
#--------------------------------------------------------------------------------------------------------------
def SilentlyPlotAllFiefs(mapClass):
    for filename in os.listdir('fiefs'):
        with open(os.path.join('fiefs', filename), 'r') as f:
            fiefClass = filename[:-4]
            fiefClass = Fiefdom()
            fiefClass.name = filename[:-4]
            fiefClass.read()
            SilentlyPlaceFiefInWorldMap(fiefClass, mapClass)

#--------------------------------------------------------------------------------------------------------------
#   [SilentlyPlotAllStrongholds]
#   Parameters: mapClass
#   Plots all stronghold files on the world map (this won't be used too often, since strongholds will
#   typically be added one at a time as new users are made). This version has no prints.
#--------------------------------------------------------------------------------------------------------------
def SilentlyPlotAllStrongholds(mapClass):
    for filename in os.listdir('strongholds'):
        with open(os.path.join('strongholds', filename), 'r') as f:
            strongholdClass = filename[:-4]
            strongholdClass = Stronghold()
            strongholdClass.name = filename[:-4]
            strongholdClass.read()
            SilentlyPlaceStrongholdInWorldMap(strongholdClass, mapClass)

#--------------------------------------------------------------------------------------------------------------
#   [SilentlyDefineFiefBiome]
#   Parameters: fiefClass
#
#   Sets a fief's biome based on the fief's name. If no match is found, the fief is assigned a random biome 
#   instead. Does this without printing anything
#--------------------------------------------------------------------------------------------------------------
def SilentlyDefineFiefBiome(fiefClass):
    forestBiomeNames = ['forest', 'wood', 'root', 'grove', 'thicket', 'glade', 'pine', 'timber', 'covert', 'canopy', 'jungle']
    plainsBiomeNames = ['plain', 'field', 'prairie', 'flat', 'expanse', 'grass', 'meadow', 'steppe', 'plateau', 'heath', 'moor', 'hollow']
    mountainBiomeNames = ['mount', 'alp', 'bluff', 'cliff', 'crag', 'mesa', 'peak', 'range', 'ridge', 'pike', 'hill', 'butte', 'height', 'summit']
    #Check if the name sounds like a forest
    for i in range(len(forestBiomeNames)):
        if forestBiomeNames[i] in str(fiefClass.name).lower():
            fiefClass.biome = FOREST
    #Check if the name sounds like a mountain
    for i in range(len(mountainBiomeNames)):
        if mountainBiomeNames[i] in str(fiefClass.name).lower():
            fiefClass.biome = MOUNTAIN
    #Check if the name sounds like a plains
    for i in range(len(plainsBiomeNames)):
        if plainsBiomeNames[i] in str(fiefClass.name).lower():
            fiefClass.biome = PLAINS
    #Select randomly if the name doesn't sound like any of the previous biomes
    if fiefClass.biome == '0':
        fiefClass.biome = GetRandomLandPoint()
    #Update the fiefClass file
    fiefClass.write()


#--------------------------------------------------------------------------------------------------------------
#   [SilentlyRunSouthEast]
#   Parameters: dS, dSE, wMap, y, x, lean
#   Runs river southeast based on passed values
#--------------------------------------------------------------------------------------------------------------
def SilentlyRunSouthEast(dS, dSE, wMap, y, x, lean):
    if lean == 'none':
        if dS == PLAINS:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        if dSE == PLAINS:
            return SilentlySimulateRivers(wMap, RIVER[2], y + 1, x + 1)
        if dS == FOREST:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        if dSE == FOREST:
            return SilentlySimulateRivers(wMap, RIVER[2], y + 1, x + 1)
    if lean == 'south':
        if dS == PLAINS:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        if dS == FOREST:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        if dSE == PLAINS:
            return SilentlySimulateRivers(wMap, RIVER[2], y + 1, x + 1)
        if dSE == FOREST:
            return SilentlySimulateRivers(wMap, RIVER[2], y + 1, x + 1)
    if lean == 'east':
        if dSE == PLAINS:
            return SilentlySimulateRivers(wMap, RIVER[2], y + 1, x + 1)
        if dSE == FOREST:
            return SilentlySimulateRivers(wMap, RIVER[2], y + 1, x + 1)
        if dS == PLAINS:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        if dS == FOREST:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        

#--------------------------------------------------------------------------------------------------------------
#   [SilentlyRunSouthWest]
#   Parameters: dSW, dS, wMap, y, x, lean
#   Runs river southwest based on passed values
#--------------------------------------------------------------------------------------------------------------
def SilentlyRunSouthWest(dSW, dS, wMap, y, x, lean):
    if lean == 'none':
        if dS == PLAINS:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        if dSW == PLAINS:
            return SilentlySimulateRivers(wMap, RIVER[0], y + 1, x - 1)
        if dS == FOREST:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        if dSW == FOREST:
            return SilentlySimulateRivers(wMap, RIVER[0], y + 1, x - 1)
    if lean == 'south':
        if dS == PLAINS:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        if dS == FOREST:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        if dSW == PLAINS:
            return SilentlySimulateRivers(wMap, RIVER[0], y + 1, x - 1)
        if dSW == FOREST:
            return SilentlySimulateRivers(wMap, RIVER[0], y + 1, x - 1)
    if lean == 'west':
        if dSW == PLAINS:
            return SilentlySimulateRivers(wMap, RIVER[0], y + 1, x - 1)
        if dSW == FOREST:
            return SilentlySimulateRivers(wMap, RIVER[0], y + 1, x - 1)
        if dS == PLAINS:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        if dS == FOREST:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        
#--------------------------------------------------------------------------------------------------------------
#   [SilentlyRandomRunSouthWest]
#   Parameters: dSW, dS, wMap, y, x
#   Runs river southwest based on passed values
#--------------------------------------------------------------------------------------------------------------
def SilentlyRandomRunSouthWest(dSW, dS, wMap, y, x):
    ch2 = random.randint(1, 2)
    #If both dS and dSW are plains:
    if dS == PLAINS and dSW == PLAINS:
        if ch2 == 1:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        elif ch2 == 2:
            return SilentlySimulateRivers(wMap, RIVER[0], y + 1, x - 1)
    #If both dS and dSW are forests:
    elif dS == FOREST and dSW == FOREST:
        if ch2 == 1:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        elif ch2 == 2:
            return SilentlySimulateRivers(wMap, RIVER[0], y + 1, x - 1)

#--------------------------------------------------------------------------------------------------------------
#   [SilentlyRandomRunSouthEast]
#   Parameters: dSW, dS, wMap, y, x
#   Runs river southeast based on passed values, randomly selecting
#--------------------------------------------------------------------------------------------------------------
def SilentlyRandomRunSouthEast(dS, dSE, wMap, y, x):
    ch2 = random.randint(1, 2)
    #If both dS and dSE are plains:
    if dS == PLAINS and dSE == PLAINS:
        if ch2 == 1:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        elif ch2 == 2:
            return SilentlySimulateRivers(wMap, RIVER[2], y + 1, x + 1)
    #If both dS and dSE are forests:
    elif dS == FOREST and dSE == FOREST:
        if ch2 == 1:
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        elif ch2 == 2:
            return SilentlySimulateRivers(wMap, RIVER[2], y + 1, x + 1)

#--------------------------------------------------------------------------------------------------------------
#   [SilentlySimulateRivers]
#   Parameters: wMap, symbol, y, x
#   Returns: Recursively returns itself until conditions are met.
#   Draws the rivers based on their current positions.
#  
#       Function prefers to spread to plains over forests.
#       At this point, we know that if the symbol is "\", then dS and dSE are each either a forest or a plains.
#       Additionally if the symbol is "|", then dSW, dS, and dSE are each a ^ or a # too. And finally if the 
#       symbol is "/", we know that the same is true for dSW and dS.
#       When multiple options are the same, however, that is when things get complex. 
#       The preferred direction should depend on what lies on the dE and dW. 
#       If those are in the same category (( Sources: M, ~ ), ( Spreadable: #, ^ )) then it should
#       select randomly. 
#--------------------------------------------------------------------------------------------------------------
def SilentlySimulateRivers(wMap, symbol, y, x):
    global FLOOD_COUNTER
    try:
        wMap[y][x] = symbol
    except:
        return wMap

    if FLOOD_COUNTER >= FLOOD_WARNING:
        return wMap
    else:
        FLOOD_COUNTER += 1
        
    surroundings = ScanSurroundings(wMap, x, y)
    dE = surroundings[2]
    dSE = surroundings[3]
    dS = surroundings[4]
    dSW = surroundings[5]
    dW = surroundings[6]

    # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    # If river is headed southeast:
    # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    if symbol == RIVER[2]:
        #if dW and dE are in the same category:
        if ((dW == MOUNTAIN or dW == WATER) and (dE == MOUNTAIN or dE == WATER)) or ((dW != MOUNTAIN or dW != WATER) and (dE != MOUNTAIN or dE != WATER)):
            #First, run to see if dS and dSE are the same, and choose randomly in that case:
            SilentlyRandomRunSouthEast(dS, dE, wMap, y, x)
            #If they were not the same, then just check for plains first:
            SilentlyRunSouthEast(dS, dE, wMap, y, x, 'none')

        #Otherwise, if west is not spreadable
        elif dW == MOUNTAIN or dW == WATER:
            #If both dS and dSE are plains:
            if dS == PLAINS and dSE == PLAINS:
                #Prefer the east:
                return SilentlySimulateRivers(wMap, RIVER[2], y + 1, x + 1)
            #If both dS and dSE are forests:
            elif dS == FOREST and dSE == FOREST:
                #Prefer the east:
                return SilentlySimulateRivers(wMap, RIVER[2], y + 1, x + 1)
            #if dS and dSE are not the same:
            else:
                SilentlyRunSouthEast(dS, dE, wMap, y, x, 'east')

        #Otherwise, if east is not spreadable
        elif dE == MOUNTAIN or dE == WATER:
            #If both dS and dSE are plains:
            if dS == PLAINS and dSE == PLAINS:
                #Prefer the south:
                return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
            #If both dS and dSE are forests:
            elif dS == FOREST and dSE == FOREST:
                #Prefer the south:
                return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
            #if dS and dSE are not the same:
            else:
                SilentlyRunSouthEast(dS, dE, wMap, y, x, 'south')

    # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    # If a river is headed southwest:
    # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    elif symbol == RIVER[0]:
        #if dW and dE are in the same category:
        if ((dW == MOUNTAIN or dW == WATER) and (dE == MOUNTAIN or dE == WATER)) or ((dW != MOUNTAIN or dW != WATER) and (dE != MOUNTAIN or dE != WATER)):
            #First, run to see if dS and dSE are the same, and choose randomly in that case:
            SilentlyRandomRunSouthWest(dSW, dS, wMap, y, x)
            #If they were not the same, then just check for plains first:
            SilentlyRunSouthWest(dSW, dS, wMap, y, x, 'none')

        #Otherwise, if east is not spreadable
        elif dE == MOUNTAIN or dE == WATER:
            #If both dS and dSE are plains:
            if dS == PLAINS and dSE == PLAINS:
                #Prefer the south:
                return SilentlySimulateRivers(wMap, RIVER[0], y + 1, x - 1)
            #If both dS and dSE are forests:
            elif dS == FOREST and dSE == FOREST:
                #Prefer the south:
                return SilentlySimulateRivers(wMap, RIVER[0], y + 1, x - 1)
            #if dS and dSE are not the same:
            else:
                SilentlyRunSouthWest(dSW, dS, wMap, y, x, 'west')

        #Otherwise, if west is not spreadable
        elif dW == MOUNTAIN or dW == WATER:
            #If both dS and dSE are plains:
            if dS == PLAINS and dSE == PLAINS:
                #Prefer the east:
                return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
            #If both dS and dSE are forests:
            elif dS == FOREST and dSE == FOREST:
                #Prefer the east:
                return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
            #if dS and dSE are not the same:
            else:
                SilentlyRunSouthWest(dSW, dS, wMap, y, x, 'south')

    # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    # If a river is headed south:
    # ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    elif symbol == RIVER[1]:
        #if neither dW nor dE are spreadable, then run south:
        if (dW == MOUNTAIN or dW == WATER) and (dE == MOUNTAIN or dE == WATER):
            return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
        #if both dW and dE are spreadable:
        elif (dW != MOUNTAIN or dW != WATER) and (dE != MOUNTAIN or dE != WATER):
            #If everything is the same to the south, then choose randomly between both directions:
            if (dSW == PLAINS and dS == PLAINS and dSE == PLAINS) or (dSW == FOREST and dS == FOREST and dSE == FOREST):
                #Then choose a random direction
                ch2 = random.randint(1, 2)
                if ch2 == 1:
                    SilentlyRandomRunSouthWest(dSW, dS, wMap, y, x)
                else:
                    SilentlyRandomRunSouthEast(dS, dSE, wMap, y, x)
            #Otherwise, check plains if one side has two plains first before deciding:
            elif (dSW == PLAINS and dS == PLAINS):
                SilentlyRandomRunSouthWest(dSW, dS, wMap, y, x)
            elif (dS == PLAINS and dSE == PLAINS):
                SilentlyRandomRunSouthEast(dS, dSE, wMap, y, x)
            elif (dSW == FOREST and dS == FOREST):
                SilentlyRandomRunSouthWest(dSW, dS, wMap, y, x)
            elif (dS == FOREST and dSE == FOREST):
                SilentlyRandomRunSouthEast(dS, dSE, wMap, y, x)
            #Otherwise, check which side has a plains (at this point, exactly one plains must exist):
            elif dS == PLAINS:
                ch2 = random.randint(1, 2)
                if ch2 == 1:
                    SilentlyRunSouthWest(dSW, dS, wMap, y, x, 'south')
                else:
                    SilentlyRunSouthEast(dS, dSE, wMap, y, x, 'south')
            elif dSW == PLAINS:
                SilentlyRunSouthWest(dSW, dS, wMap, y, x, 'west')
            elif dSE == PLAINS:
                SilentlyRunSouthEast(dS, dSE, wMap, y, x, 'east')

        #Otherwise, if east is not spreadable
        elif dE == MOUNTAIN or dE == WATER:
            #If everything is plains to the south (or so long as dSW and dS are plains), then prefer southwest.
            if (dSW == PLAINS and dS == PLAINS and dSE == PLAINS) or (dSW == PLAINS and dS == PLAINS):
                SilentlyRandomRunSouthWest(dSW, dS, wMap, y, x)
            #Otherwise, if dS and dE are both plains, prefer south:
            elif dS == PLAINS and dSE == PLAINS:
                return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
            #Otherwise, if dSW is the only plains, go southwest:
            elif dSW == PLAINS:
                return SilentlySimulateRivers(wMap, RIVER[0], y + 1, x - 1)
            #Otherwise, if dS is the only plains, go south:
            elif dS == PLAINS:
                return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)

            #Otherwise, everything south must just be forests, so run randomly to the southwest:
            SilentlyRandomRunSouthWest(dSW, dS, wMap, y, x)

        #Otherwise, if west is not spreadable
        elif dW == MOUNTAIN or dW == WATER:
            #If everything is plains to the south (or so long as dSE and dS are plains), then prefer southeast.
            if (dSW == PLAINS and dS == PLAINS and dSE == PLAINS) or (dSE == PLAINS and dS == PLAINS):
                SilentlyRandomRunSouthEast(dS, dSE, wMap, y, x)
            #Otherwise, if dS and dW are both plains, prefer south:
            elif dS == PLAINS and dSW == PLAINS:
                return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)
            #Otherwise, if dSE is the only plains, go southeast:
            elif dSE == PLAINS:
                return SilentlySimulateRivers(wMap, RIVER[2], y + 1, x + 1)
            #Otherwise, if dS is the only plains, go south:
            elif dS == PLAINS:
                return SilentlySimulateRivers(wMap, RIVER[1], y + 1, x)

            #Otherwise, everything south must just be forests, so run randomly to the southeast:
            SilentlyRandomRunSouthEast(dS, dSE, wMap, y, x)



#--------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------
#                                           TEST FUNCTIONS
#--------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------



#--------------------------------------------------------------------------------------------------------------
#   [TestCrossCheckFiefCoordinates]
#   Parameters: coordinates
#   Returns: True if no other fiefs have the same coordinates
#
#   Issues: This is a bit tedious, having to check each file this way. Another way to make this work could be
#   to have an list stored in the Map object that contains tuples of coordinates that are occupied by fiefs.
#   This way, strongholds could benefit from that as well. For now, I'm not so sure I want to mess with the 
#   currently functional map class though after all the read/write woes. 
#--------------------------------------------------------------------------------------------------------------
def TestCrossCheckFiefCoordinates(coordinates):
    
    for filename in os.listdir('tests/testFiefs'):
            with open(os.path.join('tests/testFiefs', filename), 'r') as f:
                tempName = filename[:-4]
                tempName = Fiefdom()
                tempName.name = filename[:-4]
                tempName.read()
                # print('Cross checking with: ' + str(tempName.name))
                if tempName.yCoordinate == coordinates[0] and tempName.xCoordinate == coordinates[1]:
                    print('    Error, same coordinates as ' + str(tempName.name) + '!')
                    return False
    return True

#--------------------------------------------------------------------------------------------------------------
#   [TestQuietlyPlaceFiefInWorldMap]
#   Parameters: fiefClass, mapClass
#
#   Test Function - Sets a fief's biome based on the fief's name. If no match is found, the fief is assigned a 
#   random biome instead. This version doesn't print as much diagnostic stuff.
#--------------------------------------------------------------------------------------------------------------
def TestQuietlyPlaceFiefInWorldMap(fiefClass, mapClass):
    if (fiefClass.biome == '0') and (fiefClass.name != 'Default Fiefdom'):
        DefineFiefBiome(fiefClass)
        remaining = 0
        cycle = 0
        pickingPoint = 0
        spotFound = False

        #Check if there are still biome slots open for a particular biome.
        #If none are available, then change the fief's biome and try again.
        #If there aren't any open spots at all, then stop the loop.
        while remaining == 0 and cycle < 4:
            remaining = CheckRemainingBiomes(fiefClass.biome, mapClass)
            if remaining == 0:
                fiefClass.biome = CycleBiome(fiefClass.biome)
                cycle += 1
        if cycle > 3:
            print('    Error, no more room for fiefs left on this map!')
        else:
            while pickingPoint < 10:    #Tries to get a point. Fails if it manages to select an occupied point 10 times.
                #Select one of the available biomes at random
                point = GetRandomPointByBiome(fiefClass.biome, mapClass)
                #If a biome was found:
                if point > 0:
                    coordinates = GetPointCoordinates(fiefClass.biome, point, mapClass.worldMap)

                    if TestCrossCheckFiefCoordinates(coordinates):
                        print(*coordinates)
                        fiefClass.setCoordinates(coordinates)
                        UpdateUsedBiomes(fiefClass.biome, mapClass)
                        InsertFiefAtLocation(fiefClass.yCoordinate, fiefClass.xCoordinate, mapClass)
                        
                        PrintColorMap(mapClass.worldMap)

                        fiefClass.write()
                        pickingPoint = 10
                        spotFound = True
                    else:
                        pickingPoint += 1
            if spotFound == False:
                print("    Error, couldn't find an empty spot!")
    else:
        if fiefClass.name == 'Default Fiefdom':
            print("    That fiefdom doesn't exist!")
        else:
            print('    ' + str(fiefClass.name) + ' is already on the map!')


#--------------------------------------------------------------------------------------------------------------
#   [TestPlotAllFiefs]
#   Parameters: mapClass
#   Test Function - Plots all fief files on the world map
#--------------------------------------------------------------------------------------------------------------
def TestPlotAllFiefs(mapClass):
    for filename in os.listdir('tests/testFiefs'):
        with open(os.path.join('tests/testFiefs', filename), 'r') as f:
            time.sleep(1)
            os.system("clear")
            fiefClass = filename[:-4]
            fiefClass = TestFiefdom()
            fiefClass.name = filename[:-4]
            fiefClass.read()
            TestQuietlyPlaceFiefInWorldMap(fiefClass, mapClass)


#--------------------------------------------------------------------------------------------------------------
#   [TestResetFiefCoordinates]
#   Parameters: mapClass
#   Test Function - Resets the coordinates of all fiefs so that they can be placed again.
#--------------------------------------------------------------------------------------------------------------
def TestResetFiefCoordinates():
    for filename in os.listdir('tests/testFiefs'):
        with open(os.path.join('tests/testFiefs', filename), 'r') as f:
            fiefClass = filename[:-4]
            fiefClass = TestFiefdom()
            fiefClass.name = filename[:-4]
            fiefClass.biome = '0'
            fiefClass.xCoordinate = 0
            fiefClass.yCoordinate = 0
            fiefClass.nearWater = False
            fiefClass.write()








#--------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------
#                                           Misc. Functions
#--------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------

#--------------------------------------------------------------------------------------------------------------
#   [LoadingAnimationIncrementor]
#   Parameter: cap
#
#   Uses a global variable to cycle through a loading animation and returns a number based on the cap passed
#--------------------------------------------------------------------------------------------------------------
def LoadingAnimationIncrementor(cap):
    global LOADING_INCREMENT

    if LOADING_INCREMENT > cap:
        LOADING_INCREMENT = 0
    else:
        LOADING_INCREMENT += 1

    return LOADING_INCREMENT

#--------------------------------------------------------------------------------------------------------------
#   [LoadingAnimation]
#   Parameter: thingLoading
#
#   Prints a passed string with an animation after it that changes each time the screen is refreshed.
#   Function should be used in loops where the system is being cleared several times.
#   I didn't end up using this, so I converted it into an artificial loading function to go before something
#   and slow it down for no reason besides having a transition.
#--------------------------------------------------------------------------------------------------------------
def LoadingAnimation(thingLoading):
    os.system("clear")
    frame = LoadingAnimationIncrementor(4)
    if frame == 0:
        print(thingLoading)
    elif frame == 1:
        print(thingLoading + '.')
    elif frame == 2:
        print(thingLoading + '..')
    else:
        print(thingLoading + '...')
    time.sleep(0.1)




#--------------------------------------------------------------------------------------------------------------
#   [PositionOffMap]
#   parameters: y, x
#   returns: True/False  -  if either coordinate is off the map
#--------------------------------------------------------------------------------------------------------------
def PositionOffMap(y, x):
    if int(y) < 0:
        return True
    if int(x) < 0: 
        return True
    if int(y) >= MAP_HEIGHT:
        return True
    if int(x) >= MAP_WIDTH:
        return True

    return False


#--------------------------------------------------------------------------------------------------------------
#   [FarScanSurroundings]
#   parameters: mapClass, posY, posX
#   returns: 2d list of surroundings (2 spaces out from center)
#--------------------------------------------------------------------------------------------------------------
def FarScanSurroundings(mapClass, y, x):
    wMap = mapClass.worldMap
    posY = int(y)
    posX = int(x)

    C = LOCATION
    try:
        dN = wMap[posY - 1][posX]
        if PositionOffMap(posY-1, posX):
            dN = ' '
    except:
        dN = ' '
    try:
        dNN = wMap[posY - 2][posX]
        if PositionOffMap(posY-2, posX):
            dNN = ' '
    except:
        dNN = ' '
    try:
        dNE = wMap[posY - 1][posX + 1]
        if PositionOffMap(posY-1, posX+1):
            dNE = ' '
    except:
        dNE = ' '
    try:
        dNNE = wMap[posY - 2][posX + 1]
        if PositionOffMap(posY-2, posX+1):
            dNNE = ' '
    except:
        dNNE = ' '
    try:
        dNNEE = wMap[posY - 2][posX + 2]
        if PositionOffMap(posY-2, posX+2):
            dNNEE = ' '
    except:
        dNNEE = ' '
    try:
        dNEE = wMap[posY - 1][posX + 2]
        if PositionOffMap(posY-1, posX+2):
            dNEE = ' '
    except:
        dNEE = ' '
    try:
        dE = wMap[posY][posX + 1]
        if PositionOffMap(posY, posX+1):
            dE = ' '
    except:
        dE = ' '
    try:
        dEE = wMap[posY][posX + 2]
        if PositionOffMap(posY, posX+2):
            dEE = ' '
    except:
        dEE = ' '
    try:
        dSE = wMap[posY + 1][posX + 1]
        if PositionOffMap(posY+1, posX+1):
            dSE = ' '
    except:
        dSE = ' '
    try:
        dSEE = wMap[posY + 1][posX + 2]
        if PositionOffMap(posY+1, posX+2):
            dSEE = ' '
    except:
        dSEE = ' '
    try:
        dSSEE = wMap[posY + 2][posX + 2]
        if PositionOffMap(posY+2, posX+2):
            dSSEE = ' '
    except:
        dSSEE = ' '
    try:
        dSSE = wMap[posY + 2][posX + 1]
        if PositionOffMap(posY+2, posX+1):
            dSSE = ' '
    except:
        dSSE = ' '
    try:
        dS = wMap[posY + 1][posX]
        if PositionOffMap(posY+1, posX):
            dS = ' '
    except:
        dS = ' '
    try:
        dSS = wMap[posY + 2][posX]
        if PositionOffMap(posY+2, posX):
            dSS = ' '
    except:
        dSS = ' '
    try:
        dSW = wMap[posY + 1][posX - 1]
        if PositionOffMap(posY+1, posX-1):
            dSW = ' '
    except:
        dSW = ' '
    try:
        dSSW = wMap[posY + 2][posX - 1]
        if PositionOffMap(posY+2, posX-1):
            dSSW = ' '
    except:
        dSSW = ' '
    try:
        dSSWW = wMap[posY + 2][posX - 2]
        if PositionOffMap(posY+2, posX-2):
            dSSWW = ' '
    except:
        dSSWW = ' '
    try:
        dSWW = wMap[posY + 1][posX - 2]
        if PositionOffMap(posY+1, posX-2):
            dSWW = ' '
    except:
        dSWW = ' '
    try:
        dW = wMap[posY][posX - 1]
        if PositionOffMap(posY, posX-1):
            dW = ' '
    except:
        dW = ' '
    try:
        dWW = wMap[posY][posX - 2]
        if PositionOffMap(posY, posX-2):
            dWW = ' '
    except:
        dWW = ' '
    try:
        dNW = wMap[posY - 1][posX - 1]
        if PositionOffMap(posY-1, posX-1):
            dNW = ' '
    except:
        dNW = ' '
    try:
        dNWW = wMap[posY - 1][posX - 2]
        if PositionOffMap(posY-1, posX-2):
            dNWW = ' '
    except:
        dNWW = ' '
    try:
        dNNWW = wMap[posY - 2][posX - 2]
        if PositionOffMap(posY-2, posX-2):
            dNNWW = ' '
    except:
        dNNWW = ' '
    try:
        dNNW = wMap[posY - 2][posX - 1]
        if PositionOffMap(posY-2, posX-1):
            dNNW = ' '
    except:
        dNNW = ' '

    # return [dN, dNE, dE, dSE, dS, dSW, dW, dNW]
    # return [dN, dNN, dNE, dNNE, dNNEE, dNEE, dE, dEE, dSE, dSEE, dSSEE, dSSE, dS, dSS, dSW, dSSW, dSSWW, dSWW, dW, dWW, dNW, dNWW, dNNWW, dNNW]
    return [[dNNWW, dNNW, dNN, dNNE, dNNEE], [dNWW, dNW, dN, dNE, dNEE], [dWW, dW, C, dE, dEE], [dSWW, dSW, dS, dSE, dSEE], [dSSWW, dSSW, dSS, dSSE, dSSEE]]

#--------------------------------------------------------------------------------------------------------------
#   [PrintMiniMap]
#   parameters: mList
#       prints out a minimap based on passed 2d-list
#--------------------------------------------------------------------------------------------------------------
def PrintMiniMap(mList, y, x):
    borderColor = RED_GRAY
    borderSymb = str('-')
    print(borderColor + "    " + str("Surroundings").center(19, borderSymb) + RESET)
    for i in range(len(mList)):
        print(str(borderColor + "    " + borderSymb + RESET), sep='', end=' ', flush=True)
        for j in range(len(mList[i])):
            if str(mList[i][j]) == WATER:
                print(str(IC_WATER + " " + str(mList[i][j]) + RESET), sep='', end=' ', flush=True)
            elif str(mList[i][j]) == RIVER[0]:
                print(str(IC_RIVER + " " + str(mList[i][j]) + RESET), sep='', end=' ', flush=True)
            elif str(mList[i][j]) == RIVER[1]:
                print(str(IC_RIVER + " " + str(mList[i][j]) + RESET), sep='', end=' ', flush=True)
            elif str(mList[i][j]) == RIVER[2]:
                print(str(IC_RIVER + " " + str(mList[i][j]) + RESET), sep='', end=' ', flush=True)
            elif str(mList[i][j]) == PLAINS:
                print(str(IC_PLAINS + " " + str(mList[i][j]) + RESET), sep='', end=' ', flush=True)
            elif str(mList[i][j]) == FOREST:
                print(str(IC_FOREST + " " + str(mList[i][j]) + RESET), sep='', end=' ', flush=True)
            elif str(mList[i][j]) == MOUNTAIN:
                print(str(IC_MOUNTAIN + " " + str(mList[i][j]) + RESET), sep='', end=' ', flush=True)
            elif str(mList[i][j]) == FIEF:
                print(str(IC_FIEF + " " + str(mList[i][j]) + RESET), sep='', end=' ', flush=True)
            elif str(mList[i][j]) == STRONGHOLD:
                print(str(IC_STRONGHOLD + " " + str(mList[i][j]) + RESET), sep='', end=' ', flush=True)
            elif str(mList[i][j]) == LOCATION:
                print(str(BLUE_GRAY + " " + str(mList[i][j]) + RESET), sep='', end=' ', flush=True)
            else:
                print(str(NAVY + " " + str("*" + RESET)), sep='', end=' ', flush=True)
        print(borderColor + " " + borderSymb + RESET)
    print(str(borderColor + "    " + str("(" + RESET + str(x) + ", " + str(y) + borderColor + ")").center(34, borderSymb) + RESET))

#--------------------------------------------------------------------------------------------------------------
#   [GenerateMiniMap]
#   parameters: mapClass, yPos, xPos
#       Creates and prints out a minimap
#--------------------------------------------------------------------------------------------------------------
def GenerateMiniMap(mapClass, yPos, xPos):
    mList = FarScanSurroundings(mapClass, yPos, xPos)
    PrintMiniMap(mList, yPos, xPos)



#--------------------------------------------------------------------------------------------------------------
#   [PrintWorldMapWithLocation]
#   Parameters: wMap, userName, yPos, xPos
#   Iterates through a WorldMap and prints a color version. Also prints fiefs along side
#--------------------------------------------------------------------------------------------------------------
def PrintWorldMapWithLocation(wMap, userName, yPos, xPos):
    for i in range(MAP_HEIGHT):
        fiefsInRow = GetFiefRow(i, userName)
        strongholdsInRow = GetStrongholdRow(i, userName)
        for j in range(MAP_WIDTH):
            symbol = wMap[i][j]
            if j == 0:
                if j == int(xPos) and i == int(yPos):
                    print(MAP_SPACER + IC_LOCATION + LOCATION + RESET, end=" ")
                elif symbol == UNEXPLORED:
                    print(MAP_SPACER + IC_UNEXPLORED + symbol + RESET, end=" ")
                elif symbol == EMPTY:
                    print(MAP_SPACER + symbol, end=" ")
                elif symbol == WATER:
                    print(MAP_SPACER + IC_WATER + symbol + RESET, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(MAP_SPACER + IC_RIVER + symbol + RESET, end=" ")
                elif symbol == FOREST:
                    print(MAP_SPACER + IC_FOREST + symbol + RESET, end=" ")
                elif symbol == PLAINS:
                    print(MAP_SPACER + IC_PLAINS + symbol + RESET, end=" ")
                elif symbol == MOUNTAIN:
                    print(MAP_SPACER + IC_MOUNTAIN + symbol + RESET, end=" ")
                elif symbol == FIEF:
                    print(MAP_SPACER + GetFiefByOwner(i, j, userName) + RESET, end=" ")
                elif symbol == STRONGHOLD:
                    print(MAP_SPACER + IC_STRONGHOLD + symbol + RESET, end=" ")
                elif symbol == LOCATION:
                    print(MAP_SPACER + IC_LOCATION + symbol + RESET, end=" ")
            elif j == MAP_WIDTH - 1:
                if j == int(xPos) and i == int(yPos):
                    print(IC_LOCATION + LOCATION + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == UNEXPLORED:
                    print(IC_UNEXPLORED + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == EMPTY:
                    print(symbol, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == WATER:
                    print(IC_WATER + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(IC_RIVER + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == FOREST:
                    print(IC_FOREST + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == PLAINS:
                    print(IC_PLAINS + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == MOUNTAIN:
                    print(IC_MOUNTAIN + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == FIEF:
                    print(GetFiefByOwner(i, j, userName) + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == STRONGHOLD:
                    print(IC_STRONGHOLD + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
                elif symbol == LOCATION:
                    print(IC_LOCATION + symbol + RESET, *fiefsInRow, *strongholdsInRow, end=" ")
            else:
                if j == int(xPos) and i == int(yPos):
                    print(IC_LOCATION + LOCATION + RESET, end=" ")
                elif symbol == UNEXPLORED:
                    print(IC_UNEXPLORED + symbol + RESET, end=" ")
                elif symbol == EMPTY:
                    print(symbol, end=" ")
                elif symbol == WATER:
                    print(IC_WATER + symbol + RESET, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(IC_RIVER + symbol + RESET, end=" ")
                elif symbol == FOREST:
                    print(IC_FOREST + symbol + RESET, end=" ")
                elif symbol == PLAINS:
                    print(IC_PLAINS + symbol + RESET, end=" ")
                elif symbol == MOUNTAIN:
                    print(IC_MOUNTAIN + symbol + RESET, end=" ")
                elif symbol == FIEF:
                    print(GetFiefByOwner(i, j, userName) + RESET, end=" ")
                elif symbol == STRONGHOLD:
                    print(IC_STRONGHOLD + symbol + RESET, end=" ")
                elif symbol == LOCATION:
                    print(IC_LOCATION + symbol + RESET, end=" ")
        print('')

#--------------------------------------------------------------------------------------------------------------
#   [GetFiefByCoordinates]
#   Parameters: yPos, xPos
#   Returns: fief class at coordinates
#--------------------------------------------------------------------------------------------------------------
def GetFiefByCoordinates(yPos, xPos):
    for filename in os.listdir('fiefs'):
            with open(os.path.join('fiefs', filename), 'r') as f:
                tempName = filename[:-4]
                tempName = Fiefdom()
                tempName.name = filename[:-4]
                tempName.read()
                if int(tempName.yCoordinate) == int(yPos) and int(tempName.xCoordinate) == int(xPos):
                    return tempName
#--------------------------------------------------------------------------------------------------------------
#   [GetStrongholdByCoordinates]
#   Parameters: yPos, xPos
#   Returns: fief class at coordinates
#--------------------------------------------------------------------------------------------------------------
def GetStrongholdByCoordinates(yPos, xPos):
    for filename in os.listdir('strongholds'):
            with open(os.path.join('strongholds', filename), 'r') as f:
                tempName = filename[:-4]
                tempName = Stronghold()
                tempName.name = filename[:-4]
                tempName.read()
                if int(tempName.yCoordinate) == int(yPos) and int(tempName.xCoordinate) == int(xPos):
                    return tempName

#--------------------------------------------------------------------------------------------------------------
#   [GetLocation]
#   Parameters: mapClass, yPos, xPos
#
#   Looks at current location and determines if there is something there. Returns the name of that thing if
#   something is found. Otherwise returns "".
#--------------------------------------------------------------------------------------------------------------
def GetLocation(mapClass, yPos, xPos):
    if str(mapClass.worldMap[int(yPos)][int(xPos)]) == FIEF:
        tempFief = Fiefdom()
        tempFief = GetFiefByCoordinates(yPos, xPos)
        if isinstance(tempFief, Fiefdom):
            return (str(BiomeColor(tempFief.biome) + str(tempFief.name) + RESET), "fief", str(tempFief.name))
        else:
            return ("", "", "")
        
    elif str(mapClass.worldMap[int(yPos)][int(xPos)]) == STRONGHOLD:
        tempStronghold = Stronghold()
        tempStronghold = GetStrongholdByCoordinates(yPos, xPos)
        if isinstance(tempStronghold, Stronghold):
            return (str(StrongholdColor(tempStronghold.color) + str(tempStronghold.name) + "'s Stronghold" + RESET), "stronghold", str(tempStronghold.name))
        else:
            return ("", "", "")
        
    else:
        return ("", "", "")

#--------------------------------------------------------------------------------------------------------------
#   [BattalionAtCoords]
#   Parameters: y, x, coords
#   Returns: list depending on rather there is a battalion at the passed coordinates
#--------------------------------------------------------------------------------------------------------------
def BattalionAtCoords(y, x, coords):
    for i in range(len(coords)):
        if int(y) == int(coords[i][0]) and int(x) == int(coords[i][1]):
            return coords[i]
    return ""

#--------------------------------------------------------------------------------------------------------------
#   [GetBattalionRow]
#   Parameters: y, coords
#   Returns: list of battalion names
#--------------------------------------------------------------------------------------------------------------
def GetBattalionRow(y, coords):
    battalionRow = []
    foundOne = False
    for i in range(len(coords)):
        if int(y) == int(coords[i][0]):
            battalionRow.append(str("| " + BattalionIconColor(coords[i][4]) + coords[i][3] + RESET))
            foundOne = True
    return battalionRow

#--------------------------------------------------------------------------------------------------------------
#   [PrintWorldMapWithBattalionsAndLocations]
#   Parameters: wMap, userName, coords, yPos, xPos
#
#   Iterates through a WorldMap and prints a color version. Also prints fiefs along side
#   Prints location on the map given passed coordinates
#   Prints colored Battalion icons over other locations (besides current location)
#--------------------------------------------------------------------------------------------------------------
def PrintWorldMapWithBattalionsAndLocations(wMap, userName, coords, yPos, xPos):
    for i in range(MAP_HEIGHT):
        fiefsInRow = GetFiefRow(i, userName)
        strongholdsInRow = GetStrongholdRow(i, userName)
        battalionsInRow = GetBattalionRow(i, coords)
        for j in range(MAP_WIDTH):
            battalion = ""
            symbol = wMap[i][j]
            if battalionsInRow != "":
                battalion = BattalionAtCoords(i, j, coords)
            if j == 0:
                if j == int(xPos) and i == int(yPos):
                    print(MAP_SPACER + IC_LOCATION + LOCATION + RESET, end=" ")
                elif battalion != "":
                    print(MAP_SPACER + BattalionIconColor(battalion[4]) + BATTALION + RESET, end=" ")
                elif symbol == UNEXPLORED:
                    print(MAP_SPACER + IC_UNEXPLORED + symbol + RESET, end=" ")
                elif symbol == EMPTY:
                    print(MAP_SPACER + symbol, end=" ")
                elif symbol == WATER:
                    print(MAP_SPACER + IC_WATER + symbol + RESET, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(MAP_SPACER + IC_RIVER + symbol + RESET, end=" ")
                elif symbol == FOREST:
                    print(MAP_SPACER + IC_FOREST + symbol + RESET, end=" ")
                elif symbol == PLAINS:
                    print(MAP_SPACER + IC_PLAINS + symbol + RESET, end=" ")
                elif symbol == MOUNTAIN:
                    print(MAP_SPACER + IC_MOUNTAIN + symbol + RESET, end=" ")
                elif symbol == FIEF:
                    print(MAP_SPACER + GetFiefByOwner(i, j, userName) + RESET, end=" ")
                elif symbol == STRONGHOLD:
                    print(MAP_SPACER + IC_STRONGHOLD + symbol + RESET, end=" ")
                elif symbol == LOCATION:
                    print(MAP_SPACER + IC_LOCATION + symbol + RESET, end=" ")
            elif j == MAP_WIDTH - 1:
                if j == int(xPos) and i == int(yPos):
                    print(IC_LOCATION + LOCATION + RESET, *fiefsInRow, *strongholdsInRow, *battalionsInRow, end=" ")
                elif battalion != "":
                    print(BattalionIconColor(battalion[4]) + BATTALION + RESET, *fiefsInRow, *strongholdsInRow, *battalionsInRow, end=" ")
                elif symbol == UNEXPLORED:
                    print(IC_UNEXPLORED + symbol + RESET, *fiefsInRow, *strongholdsInRow, *battalionsInRow, end=" ")
                elif symbol == EMPTY:
                    print(symbol, *fiefsInRow, *strongholdsInRow, *battalionsInRow, end=" ")
                elif symbol == WATER:
                    print(IC_WATER + symbol + RESET, *fiefsInRow, *strongholdsInRow, *battalionsInRow, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(IC_RIVER + symbol + RESET, *fiefsInRow, *strongholdsInRow, *battalionsInRow, end=" ")
                elif symbol == FOREST:
                    print(IC_FOREST + symbol + RESET, *fiefsInRow, *strongholdsInRow, *battalionsInRow, end=" ")
                elif symbol == PLAINS:
                    print(IC_PLAINS + symbol + RESET, *fiefsInRow, *strongholdsInRow, *battalionsInRow, end=" ")
                elif symbol == MOUNTAIN:
                    print(IC_MOUNTAIN + symbol + RESET, *fiefsInRow, *strongholdsInRow, *battalionsInRow, end=" ")
                elif symbol == FIEF:
                    print(GetFiefByOwner(i, j, userName) + RESET, *fiefsInRow, *strongholdsInRow, *battalionsInRow, end=" ")
                elif symbol == STRONGHOLD:
                    print(IC_STRONGHOLD + symbol + RESET, *fiefsInRow, *strongholdsInRow, *battalionsInRow, end=" ")
                elif symbol == LOCATION:
                    print(IC_LOCATION + symbol + RESET, *fiefsInRow, *strongholdsInRow, *battalionsInRow, end=" ")
            else:
                if j == int(xPos) and i == int(yPos):
                    print(IC_LOCATION + LOCATION + RESET, end=" ")
                elif battalion != "":
                    print(BattalionIconColor(battalion[4]) + BATTALION + RESET, end=" ")
                elif symbol == UNEXPLORED:
                    print(IC_UNEXPLORED + symbol + RESET, end=" ")
                elif symbol == EMPTY:
                    print(symbol, end=" ")
                elif symbol == WATER:
                    print(IC_WATER + symbol + RESET, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(IC_RIVER + symbol + RESET, end=" ")
                elif symbol == FOREST:
                    print(IC_FOREST + symbol + RESET, end=" ")
                elif symbol == PLAINS:
                    print(IC_PLAINS + symbol + RESET, end=" ")
                elif symbol == MOUNTAIN:
                    print(IC_MOUNTAIN + symbol + RESET, end=" ")
                elif symbol == FIEF:
                    print(GetFiefByOwner(i, j, userName) + RESET, end=" ")
                elif symbol == STRONGHOLD:
                    print(IC_STRONGHOLD + symbol + RESET, end=" ")
                elif symbol == LOCATION:
                    print(IC_LOCATION + symbol + RESET, end=" ")
        print('')

#--------------------------------------------------------------------------------------------------------------
#   [PrintWorldMapWithBattalions]
#   Parameters: wMap, userName, coords, yPos, xPos
#
#   Iterates through a WorldMap and prints a color version. Also prints fiefs along side
#   Prints location on the map given passed coordinates
#   Prints colored Battalion icons over other locations (besides current location)
#--------------------------------------------------------------------------------------------------------------
def PrintWorldMapWithBattalions(wMap, userName, coords, yPos, xPos):
    for i in range(MAP_HEIGHT):
        battalionsInRow = GetBattalionRow(i, coords)
        for j in range(MAP_WIDTH):
            battalion = ""
            symbol = wMap[i][j]
            if battalionsInRow != "":
                battalion = BattalionAtCoords(i, j, coords)
            if j == 0:
                if j == int(xPos) and i == int(yPos):
                    print(MAP_SPACER + IC_LOCATION + LOCATION + RESET, end=" ")
                elif battalion != "":
                    print(MAP_SPACER + BattalionIconColor(battalion[4]) + BATTALION + RESET, end=" ")
                elif symbol == UNEXPLORED:
                    print(MAP_SPACER + IC_UNEXPLORED + symbol + RESET, end=" ")
                elif symbol == EMPTY:
                    print(MAP_SPACER + symbol, end=" ")
                elif symbol == WATER:
                    print(MAP_SPACER + IC_WATER + symbol + RESET, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(MAP_SPACER + IC_RIVER + symbol + RESET, end=" ")
                elif symbol == FOREST:
                    print(MAP_SPACER + IC_FOREST + symbol + RESET, end=" ")
                elif symbol == PLAINS:
                    print(MAP_SPACER + IC_PLAINS + symbol + RESET, end=" ")
                elif symbol == MOUNTAIN:
                    print(MAP_SPACER + IC_MOUNTAIN + symbol + RESET, end=" ")
                elif symbol == FIEF:
                    print(MAP_SPACER + GetFiefByOwner(i, j, userName) + RESET, end=" ")
                elif symbol == STRONGHOLD:
                    print(MAP_SPACER + IC_STRONGHOLD + symbol + RESET, end=" ")
                elif symbol == LOCATION:
                    print(MAP_SPACER + IC_LOCATION + symbol + RESET, end=" ")
            elif j == MAP_WIDTH - 1:
                if j == int(xPos) and i == int(yPos):
                    print(IC_LOCATION + LOCATION + RESET, *battalionsInRow, end=" ")
                elif battalion != "":
                    print(BattalionIconColor(battalion[4]) + BATTALION + RESET, *battalionsInRow, end=" ")
                elif symbol == UNEXPLORED:
                    print(IC_UNEXPLORED + symbol + RESET, *battalionsInRow, end=" ")
                elif symbol == EMPTY:
                    print(symbol, *battalionsInRow, end=" ")
                elif symbol == WATER:
                    print(IC_WATER + symbol + RESET, *battalionsInRow, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(IC_RIVER + symbol + RESET, *battalionsInRow, end=" ")
                elif symbol == FOREST:
                    print(IC_FOREST + symbol + RESET, *battalionsInRow, end=" ")
                elif symbol == PLAINS:
                    print(IC_PLAINS + symbol + RESET, *battalionsInRow, end=" ")
                elif symbol == MOUNTAIN:
                    print(IC_MOUNTAIN + symbol + RESET, *battalionsInRow, end=" ")
                elif symbol == FIEF:
                    print(GetFiefByOwner(i, j, userName) + RESET, *battalionsInRow, end=" ")
                elif symbol == STRONGHOLD:
                    print(IC_STRONGHOLD + symbol + RESET, *battalionsInRow, end=" ")
                elif symbol == LOCATION:
                    print(IC_LOCATION + symbol + RESET, *battalionsInRow, end=" ")
            else:
                if j == int(xPos) and i == int(yPos):
                    print(IC_LOCATION + LOCATION + RESET, end=" ")
                elif battalion != "":
                    print(BattalionIconColor(battalion[4]) + BATTALION + RESET, end=" ")
                elif symbol == UNEXPLORED:
                    print(IC_UNEXPLORED + symbol + RESET, end=" ")
                elif symbol == EMPTY:
                    print(symbol, end=" ")
                elif symbol == WATER:
                    print(IC_WATER + symbol + RESET, end=" ")
                elif symbol == RIVER[0] or symbol == RIVER[1] or symbol == RIVER[2]:
                    print(IC_RIVER + symbol + RESET, end=" ")
                elif symbol == FOREST:
                    print(IC_FOREST + symbol + RESET, end=" ")
                elif symbol == PLAINS:
                    print(IC_PLAINS + symbol + RESET, end=" ")
                elif symbol == MOUNTAIN:
                    print(IC_MOUNTAIN + symbol + RESET, end=" ")
                elif symbol == FIEF:
                    print(GetFiefByOwner(i, j, userName) + RESET, end=" ")
                elif symbol == STRONGHOLD:
                    print(IC_STRONGHOLD + symbol + RESET, end=" ")
                elif symbol == LOCATION:
                    print(IC_LOCATION + symbol + RESET, end=" ")
        print('')

#--------------------------------------------------------------------------------------------------------------
#   [AppendStrongholdColors]
#   parameters: coords
#       Adds stronghold color values to each tuple
#--------------------------------------------------------------------------------------------------------------
def AppendStrongholdColors(coords):
    for filename in os.listdir('strongholds'):
        with open(os.path.join('strongholds', filename), 'r') as f:
            tempName = filename[:-4]
            tempName = Stronghold()
            tempName.name = filename[:-4]
            tempName.read()
            for i in range(len(coords)):
                if str(coords[i][2]) == str(tempName.name):
                    tempList = list(coords[i])
                    tempList.append(str(tempName.color))
                    tempList = tuple(tempList)
                    coords[i] = tempList
    return coords

#--------------------------------------------------------------------------------------------------------------
#   [GenerateBattalionMap]
#   parameters: mapClass, armyClass, yPos, xPos
#       Creates and prints a world map with battalion markers
#--------------------------------------------------------------------------------------------------------------
def GenerateBattalionMap(mapClass, strongholdClass, armyClass, yPos, xPos):
    armyClass.read()
    strongholdClass.read()
    coords = armyClass.GetBattalionData()
    coords = AppendStrongholdColors(coords)
    PrintWorldMapWithBattalions(mapClass.worldMap, strongholdClass.name, coords, yPos, xPos)

#--------------------------------------------------------------------------------------------------------------
#   [GenerateBattalionMapWithLocations]
#   parameters: mapClass, armyClass, yPos, xPos
#       Creates and prints a world map with battalion markers and fief/stronghold locations
#--------------------------------------------------------------------------------------------------------------
def GenerateBattalionMapWithLocations(mapClass, strongholdClass, armyClass, yPos, xPos):
    armyClass.read()
    strongholdClass.read()
    coords = armyClass.GetBattalionData()
    coords = AppendStrongholdColors(coords)
    PrintWorldMapWithBattalionsAndLocations(mapClass.worldMap, strongholdClass.name, coords, yPos, xPos)

#eof